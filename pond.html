<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ecosystem Simulator</title>
  <style>
    :root {
      --base-hue: 200;
      /* Default hue */
      --bg-color: hsl(var(--base-hue), 15%, 8%);
      --text-color: hsl(var(--base-hue), 15%, 85%);
      --text-color-darker: hsl(var(--base-hue), 15%, 65%);
      --ui-bg-color: hsl(var(--base-hue), 15%, 15%, 0.9);
      --ui-bg-color-solid: hsl(var(--base-hue), 15%, 15%);
      --ui-border-color: hsl(var(--base-hue), 15%, 30%);
      --ui-accent-color: hsl(var(--base-hue), 50%, 50%);
      --ui-accent-hover-color: hsl(var(--base-hue), 50%, 60%);


      --plant-color: hsl(calc(var(--base-hue) + 120), 60%, 50%);
      --prey-color: hsl(calc(var(--base-hue) + 60), 70%, 60%);
      --predator-color: hsl(var(--base-hue), 70%, 60%);
      --predator-mobbed-color: hsl(calc(var(--base-hue) + 30), 80%, 65%);
      /* Orange-ish */
      --graph-grid-color: hsl(var(--base-hue), 15%, 25%);

      /* Colors for interval death statistics on population graph */
      --graph-prey-pred-death-color: hsl(calc(var(--base-hue) + 60), 55%, 40%);
      --graph-prey-starv-death-color: hsl(calc(var(--base-hue) + 60), 55%, 35%);
      --graph-pred-starv-death-color: hsl(var(--base-hue), 55%, 40%);
      --graph-pred-mob-death-color: hsl(var(--base-hue), 65%, 45%);

      /* Colors for cumulative graph */
      --graph-plant-birth-color: hsl(calc(var(--base-hue) + 120), 70%, 60%);
      /* Greenish-cyan for plant births */
      --graph-plants-consumed-color: hsl(calc(var(--base-hue) - 60), 55%, 60%);
      /* Orange/brownish for plants consumed */
      --graph-prey-birth-color: hsl(calc(var(--base-hue) + 60), 80%, 70%);
      --graph-predator-birth-color: hsl(var(--base-hue), 80%, 70%);
      --graph-total-prey-death-color: hsl(calc(var(--base-hue) + 60), 60%, 45%);
      /* A general death color for prey */
      --graph-total-predator-death-color: hsl(var(--base-hue), 60%, 45%);
      /* A general death color for predators */
      --graph-bn-error-color: hsl(calc(var(--base-hue) + 180), 80%, 70%);

      /* BN Vis Colors */
      --bn-node-param-bg: hsl(var(--base-hue), 15%, 22%);
      --bn-node-outcome-bg: hsl(var(--base-hue), 25%, 30%);
      --bn-node-border: hsl(var(--base-hue), 15%, 45%);
      --bn-edge-color: hsl(var(--base-hue), 15%, 55%);
      --bn-arrowhead-color: hsl(var(--base-hue), 15%, 75%);
      --bn-edge-color-positive: hsl(120, 50%, 55%);
      --bn-edge-color-negative: hsl(0, 60%, 60%);
      --bn-group-plant: hsl(calc(var(--base-hue) + 135), 40%, 35%);
      --bn-group-prey: hsl(calc(var(--base-hue) + 75), 45%, 40%);
      --bn-group-predator: hsl(calc(var(--base-hue) - 20), 50%, 40%);
      --bn-group-derived: hsl(var(--base-hue), 30%, 35%);
      --bn-group-outcome: hsl(calc(var(--base-hue) - 40), 55%, 35%);
    }

    body {
      margin: 0;
      overflow: hidden;
      /* Keep hidden for canvas, past runs view will manage its own scroll */
      background-color: var(--bg-color);
      color: var(--text-color);
      font-family: 'Inter', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    #simulationViewContainer,
    #pastRunsViewContainer {
      width: 100%;
      height: 100vh;
      position: relative;
    }

    #pastRunsViewContainer {
      overflow-y: auto;
      padding: 20px;
      background-color: var(--bg-color);
    }

    #pastRunsViewContainer h2,
    #pastRunsViewContainer h3,
    #pastRunsViewContainer h4 {
      color: var(--text-color);
    }


    #simulationCanvas {
      display: block;
      background-color: var(--bg-color);
    }

    .overlay {
      position: absolute;
      background-color: var(--ui-bg-color);
      border: 1px solid var(--ui-border-color);
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      transition: opacity 0.3s ease, transform 0.3s ease;
      opacity: 0;
      /* Initial state: hidden */
      transform: translateY(20px);
      /* Initial state: slightly moved for transition */
      pointer-events: none;
      max-height: 90vh;
      overflow-y: auto;
    }

    .overlay.visible {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    #statsOverlay {
      top: 20px;
      left: 20px;
      width: 300px;
    }

    #controlsOverlay {
      top: 20px;
      right: 20px;
      width: 320px;
    }

    #populationGraphCanvas,
    #cumulativeGraphCanvas,
    #bnPredictionGraphCanvas,
    #bnPredictionExtinctionGraphCanvas,
    #bnPredictionGrowthGraphCanvas,
    #bnPredictionStarvationGraphCanvas,
    #bnPredictionErrorGraphCanvas {
      width: 100%;
      height: 150px;
      background-color: hsl(var(--base-hue), 15%, 12%);
      border-radius: 4px;
      margin-top: 10px;
    }

    .overlay-toggle {
      position: absolute;
      z-index: 1001;
      background-color: var(--ui-bg-color);
      color: var(--text-color);
      border: 1px solid var(--ui-border-color);
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9em;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    }

    #statsToggle {
      top: 20px;
      left: 20px;
    }

    #controlsToggle {
      top: 20px;
      right: 20px;
    }

    #pastRunsToggleMain {
      top: 20px;
      /* Adjusted to make space if needed, or use calc */
      left: calc(20px + 80px + 20px);
      /* Assuming stats/controls toggle width around 80px */
    }


    @media (max-width: 768px) {
      #pastRunsToggleMain {
        left: 50%;
        transform: translateX(-50%);
        top: 65px;
        /* Below the other toggles */
      }

      #statsToggle {
        left: 10px;
      }

      #controlsToggle {
        right: 10px;
      }

      #statsOverlay {
        width: calc(100% - 20px);
        left: 10px;
      }

      #controlsOverlay {
        width: calc(100% - 20px);
        right: 10px;
      }
    }


    .overlay h2 {
      margin-top: 0;
      font-size: 1.2em;
      color: hsl(var(--base-hue), 20%, 90%);
      border-bottom: 1px solid var(--ui-border-color);
      padding-bottom: 5px;
      margin-bottom: 10px;
    }

    .overlay h3 {
      font-size: 1em;
      color: hsl(var(--base-hue), 20%, 80%);
      margin-top: 15px;
      margin-bottom: 5px;
    }

    .overlay label {
      display: block;
      margin: 8px 0 4px;
      font-size: 0.9em;
    }

    .overlay input[type="range"],
    .overlay input[type="number"],
    .overlay input[type="checkbox"] {
      width: calc(100% - 10px);
      margin-bottom: 10px;
    }

    .overlay input[type="checkbox"] {
      width: auto;
      margin-right: 5px;
      vertical-align: middle;
    }

    .overlay .file-input-label {
      display: block;
      /* Make it block to take full width if desired */
      text-align: center;
      cursor: pointer;
    }

    .overlay .hidden-file-input {
      display: none;
    }


    .control-group {
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px dashed var(--ui-border-color);
    }

    .control-group:last-child {
      border-bottom: none;
    }

    #pageHeader,
    #pageSubheader {
      position: absolute;
      text-align: center;
      width: 100%;
      color: var(--text-color);
      opacity: 0.8;
      pointer-events: none;
    }

    #pageHeader {
      top: 30px;
      font-size: 2em;
      font-weight: bold;
    }

    #pageSubheader {
      top: 70px;
      font-size: 1.2em;
    }

    /* Custom scrollbar for overlays */
    .overlay::-webkit-scrollbar {
      width: 8px;
    }

    .overlay::-webkit-scrollbar-track {
      background: hsl(var(--base-hue), 15%, 20%);
      border-radius: 4px;
    }

    .overlay::-webkit-scrollbar-thumb {
      background: hsl(var(--base-hue), 15%, 40%);
      border-radius: 4px;
    }

    .overlay::-webkit-scrollbar-thumb:hover {
      background: hsl(var(--base-hue), 15%, 50%);
    }

    /* Custom scrollbar for past runs view container */
    #pastRunsViewContainer::-webkit-scrollbar {
      width: 10px;
    }

    #pastRunsViewContainer::-webkit-scrollbar-track {
      background: hsl(var(--base-hue), 15%, 12%);
      border-radius: 5px;
    }

    #pastRunsViewContainer::-webkit-scrollbar-thumb {
      background: hsl(var(--base-hue), 15%, 35%);
      border-radius: 5px;
    }

    #pastRunsViewContainer::-webkit-scrollbar-thumb:hover {
      background: hsl(var(--base-hue), 15%, 45%);
    }

    /* For Firefox */
    #pastRunsViewContainer {
      scrollbar-width: thin;
      scrollbar-color: hsl(var(--base-hue), 15%, 35%) hsl(var(--base-hue), 15%, 12%);
    }

    .overlay {
      /* For Firefox overlay scrollbar */
      scrollbar-width: thin;
      scrollbar-color: hsl(var(--base-hue), 15%, 40%) hsl(var(--base-hue), 15%, 20%);
    }


    .stat-subsection {
      margin-top: 10px;
      padding-top: 5px;
      border-top: 1px solid var(--ui-border-color);
    }

    .stat-subsection.no-border-top {
      border-top: none;
      margin-top: 0;
      padding-top: 0;
    }

    .stat-subsection:first-of-type {
      margin-top: 0;
      padding-top: 0;
      border-top: none;
    }

    #pastPopulationGraphCanvas,
    #pastCumulativeGraphCanvas,
    #pastBNPredictionGraphCanvas,
    #pastBNPredictionExtinctionGraphCanvas,
    #pastBNPredictionGrowthGraphCanvas,
    #pastBNPredictionStarvationGraphCanvas {
      width: 100%;
      max-width: 600px;
      height: 200px;
      background-color: hsl(var(--base-hue), 15%, 12%);
      border-radius: 4px;
      margin-top: 10px;
      margin-left: auto;
      margin-right: auto;
    }

    .past-run-summary-graph {
      display: block;
      width: 100%;
      max-width: 280px;
      height: 100px;
      margin: 8px auto 0 auto;
      border-radius: 4px;
      background-color: hsl(var(--base-hue), 15%, 10%);
      border: 1px solid hsl(var(--base-hue), 15%, 20%);
    }


    #pastRunParamsDisplay ul,
    #pastRunStatsDisplay ul {
      list-style-type: none;
      padding-left: 5px;
    }

    #pastRunParamsDisplay li,
    #pastRunStatsDisplay li {
      margin-bottom: 3px;
      word-break: break-all;
    }

    .param-diff {
      color: hsl(calc(var(--base-hue) + 40), 60%, 65%);
      /* A slightly different highlight color */
      opacity: 0.85;
      font-size: 0.9em;
      margin-left: 5px;
    }


    #currentRunInfo.visible {
      opacity: 0.8;
    }

    .past-run-summary-item {
      padding: 10px;
      border: 1px solid var(--ui-border-color);
      border-radius: 6px;
      cursor: pointer;
      background-color: hsl(var(--base-hue), 15%, 18%);
      transition: background-color 0.2s;
    }

    .past-run-summary-item:hover {
      background-color: hsl(var(--base-hue), 15%, 25%);
    }

    .past-run-summary-item.active-selection {
      background-color: hsl(var(--base-hue), 15%, 30%);
      border-color: hsl(var(--base-hue), 20%, 50%);
    }

    #pastRunsSummaryList {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    #pastRunDetails {
      background-color: hsl(var(--base-hue), 15%, 12%);
      padding: 15px;
      border-radius: 8px;
      border: 1px solid var(--ui-border-color);
    }

    .graph-legend {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 5px 15px;
      /* row-gap column-gap */
      padding: 8px 5px;
      margin-top: 5px;
      border-top: 1px solid var(--ui-border-color);
    }

    .legend-item {
      display: flex;
      align-items: center;
      font-size: 0.8em;
      color: var(--text-color);
      opacity: 0.9;
      cursor: pointer;
    }

    .legend-item.disabled {
      opacity: 0.3;
    }

    .legend-color-swatch {
      width: 12px;
      height: 12px;
      margin-right: 6px;
      border: 1px solid hsl(var(--base-hue), 15%, 45%);
      display: inline-block;
      border-radius: 2px;
    }

    .graph-tooltip {
      position: absolute;
      z-index: 1002;
      pointer-events: none;
      font-size: 0.75em;
      background-color: var(--ui-bg-color-solid);
      color: var(--text-color);
      border: 1px solid var(--ui-border-color);
      padding: 2px 4px;
      border-radius: 3px;
      white-space: nowrap;
    }

    #bayesianNetworkVisualizationCanvas {
      width: 100%;
      height: 500px;
      background-color: var(--bg-color);
      border-radius: 6px;
      border: 1px solid var(--ui-border-color);
      margin-top: 10px;
    }

    #bayesianNetworkVisualizationContainer {
      background-color: var(--ui-bg-color-solid);
      padding: 15px;
      border-radius: 8px;
      border: 1px solid var(--ui-border-color);
    }

    #bnLegend {
      font-size: 0.75rem;
    }

    /* Basic utility classes replacing Tailwind */
    .my-2 { margin-top: 0.5rem; margin-bottom: 0.5rem; }
    .ml-3 { margin-left: 0.75rem; }
    .ml-5 { margin-left: 1.25rem; }
    .mt-1 { margin-top: 0.25rem; }
    .mt-2 { margin-top: 0.5rem; }
    .mt-3 { margin-top: 0.75rem; }
    .mt-4 { margin-top: 1rem; }
    .mt-6 { margin-top: 1.5rem; }
    .mt-8 { margin-top: 2rem; }
    .mb-2 { margin-bottom: 0.5rem; }
    .mb-4 { margin-bottom: 1rem; }
    .mb-6 { margin-bottom: 1.5rem; }
    .mb-8 { margin-bottom: 2rem; }
    .pt-1 { padding-top: 0.25rem; }
    .w-full { width: 100%; }
    .p-2 { padding: 0.5rem; }
    .p-4 { padding: 1rem; }
    .rounded-md { border-radius: 0.375rem; }
    .rounded-lg { border-radius: 0.5rem; }
    .text-sm { font-size: 0.875rem; }
    .text-xs { font-size: 0.75rem; }
    .text-lg { font-size: 1.125rem; }
    .text-xl { font-size: 1.25rem; }
    .text-2xl { font-size: 1.5rem; }
    .font-medium { font-weight: 500; }
    .font-semibold { font-weight: 600; }
    .font-bold { font-weight: 700; }
    .flex { display: flex; }
    .flex-col { flex-direction: column; }
    .flex-row { flex-direction: row; }
    .items-center { align-items: center; }
    .justify-center { justify-content: center; }
    .justify-between { justify-content: space-between; }
    .mx-auto { margin-left: auto; margin-right: auto; }
    .hidden { display: none; }
    .block { display: block; }
    .inline-block { display: inline-block; }
    .inline-flex { display: inline-flex; }
    .cursor-pointer { cursor: pointer; }
    .space-y-2 > * + * { margin-top: 0.5rem; }
    .space-x-2 > * + * { margin-left: 0.5rem; }
    .text-center { text-align: center; }
    .text-white { color: #ffffff; }
    .text-gray-300 { color: #d1d5db; }
    .text-gray-400 { color: #9ca3af; }
    .grid { display: grid; }
    .gap-6 { gap: 1.5rem; }
    .list-disc { list-style-type: disc; }
    .overflow-y-auto { overflow-y: auto; }
    .max-h-\[400px\] { max-height: 400px; }
    .fixed { position: fixed; }
    .top-5 { top: 1.25rem; }
    .right-5 { right: 1.25rem; }
    .z-10 { z-index: 10; }
    .opacity-50 { opacity: 0.5; }
    .border-t { border-top: 1px solid var(--ui-border-color); }
    .border-\[var\(--ui-border-color\)\] { border-color: var(--ui-border-color); }
    .border-opacity-30 { border-color: hsla(var(--base-hue), 15%, 30%, 0.3); }

    .bg-\[hsl\(var\(--base-hue\),15%,10%\)\] { background-color: hsl(var(--base-hue),15%,10%); }

    .btn {
      --btn-bg: var(--ui-accent-color);
      --btn-bg-hover: var(--ui-accent-hover-color);
      display: block;
      width: 100%;
      padding: 0.5rem;
      margin-top: 0.5rem;
      border-radius: 0.375rem;
      border: none;
      box-sizing: border-box;
      text-align: center;
      cursor: pointer;
      color: #ffffff;
      background-color: var(--btn-bg);
    }
    .btn:hover {
      background-color: var(--btn-bg-hover);
    }

    @media (min-width: 768px) {
      .md\:grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
  </style>
</head>

<body>
  <div id="simulationViewContainer">
    <canvas id="simulationCanvas"></canvas>

    <div id="pageHeader">Ecosystem Simulator</div>
    <div id="pageSubheader">Watch evolution unfold.</div>

    <button id="statsToggle" class="overlay-toggle">Stats</button>
    <div id="statsOverlay" class="overlay">
      <h2>Statistics</h2>
      <div>FPS: <span id="fpsDisplay">--</span></div>
      <div>BN Acc (last 20): <span id="bnAccuracyDisplay">--</span></div>
      <div class="stat-subsection">
        <h3>Populations & Interval Deaths</h3>
        <div>Plants: <span id="plantCount">0</span></div>
        <div>Prey: <span id="preyCount">0</span></div>
        <div>Predators: <span id="predatorCount">0</span></div>
        <div>Total Entities: <span id="totalEntities">0</span></div>
        <canvas id="populationGraphCanvas"></canvas>
        <div id="currentPopulationGraphLegend" class="graph-legend"></div>
      </div>
      <div class="stat-subsection">
        <h3>Cumulative Totals</h3>
        <div>Plant Births: <span id="plantBirthsDisplay">0</span></div>
        <div>Plants Consumed: <span id="plantsConsumedDisplay">0</span></div>
        <div>Prey Births: <span id="preyBirthsDisplay">0</span></div>
        <div>Predator Births: <span id="predatorBirthsDisplay">0</span></div>
        <div>Prey Deaths (Total): <span id="totalPreyDeathsDisplay">0</span></div>
        <div>Predator Deaths (Total): <span id="totalPredatorDeathsDisplay">0</span></div>
        <hr class="my-2 border-[var(--ui-border-color)] opacity-50">
        <div>Detailed Prey Deaths:</div>
        <div class="ml-3">Predation: <span id="preyPredationDeathsDisplay">0</span></div>
        <div class="ml-3">Starvation: <span id="preyStarvationDeathsDisplay">0</span></div>
        <div>Detailed Predator Deaths:</div>
        <div class="ml-3">Starvation: <span id="predatorStarvationDeathsDisplay">0</span></div>
        <div class="ml-3">Mobbing: <span id="predatorMobbingDeathsDisplay">0</span></div>
        <canvas id="cumulativeGraphCanvas"></canvas>
        <div id="currentCumulativeGraphLegend" class="graph-legend"></div>
      </div>
      <div class="stat-subsection">
        <h3>BN Predictions At Run Start (UI Params Only)</h3>
        <div class="text-sm">P(Prey Extinct): <span id="bnRunStartPreyExtinctionPrediction">--</span></div>
        <div class="text-sm">P(Predator Extinct): <span id="bnRunStartPredatorExtinctionPrediction">--</span></div>
        <div class="text-sm">P(Plant Growth > Consumpt.): <span id="bnRunStartPlantGrowthPrediction">--</span></div>
        <div class="text-sm">P(Prey Growth > Death): <span id="bnRunStartPreyGrowthPrediction">--</span></div>
        <div class="text-sm">P(Predator Growth > Death): <span id="bnRunStartPredatorGrowthPrediction">--</span></div>
        <div class="text-sm mt-1 pt-1 border-t border-[var(--ui-border-color)] border-opacity-30">P(Prey Starv. Risk):
          <span id="bnRunStartPreyStarvationRiskPrediction">--</span>
        </div>
        <div class="text-sm">P(Pred Starv. Risk): <span id="bnRunStartPredStarvationRiskPrediction">--</span></div>
      </div>
      <div class="stat-subsection">
        <h3>BN Predictions (UI Params & Live Pop.)</h3>
        <div class="text-sm">P(Prey Extinct): <span id="bnCurrentPreyExtinctionPrediction">--</span></div>
        <div class="text-sm">P(Predator Extinct): <span id="bnCurrentPredatorExtinctionPrediction">--</span></div>
        <div class="text-sm">P(Plant Growth > Consumpt.): <span id="bnCurrentPlantGrowthPrediction">--</span></div>
        <div class="text-sm">P(Prey Growth > Death): <span id="bnCurrentPreyGrowthPrediction">--</span></div>
        <div class="text-sm">P(Predator Growth > Death): <span id="bnCurrentPredatorGrowthPrediction">--</span></div>
        <div class="text-sm mt-1 pt-1 border-t border-[var(--ui-border-color)] border-opacity-30">P(Prey Starv. Risk):
          <span id="bnCurrentPreyStarvationRiskPrediction">--</span>
        </div>
        <div class="text-sm">P(Pred Starv. Risk): <span id="bnCurrentPredStarvationRiskPrediction">--</span></div>
      </div>
      <div class="stat-subsection">
        <h3>BN Prediction Trends (UI Params & Live Pop.)</h3>
        <canvas id="bnPredictionGraphCanvas"></canvas>
        <div id="bnPredictionGraphLegend" class="graph-legend"></div>
      </div>
      <div class="stat-subsection">
        <h3>BN Prediction Trends - Extinction</h3>
        <canvas id="bnPredictionExtinctionGraphCanvas"></canvas>
        <div id="bnPredictionExtinctionGraphLegend" class="graph-legend"></div>
      </div>
      <div class="stat-subsection">
        <h3>BN Prediction Trends - Growth</h3>
        <canvas id="bnPredictionGrowthGraphCanvas"></canvas>
        <div id="bnPredictionGrowthGraphLegend" class="graph-legend"></div>
      </div>
      <div class="stat-subsection">
        <h3>BN Prediction Trends - Starvation Risk</h3>
        <canvas id="bnPredictionStarvationGraphCanvas"></canvas>
        <div id="bnPredictionStarvationGraphLegend" class="graph-legend"></div>
      </div>
    </div>
  </div>
  <div id="graphTooltip" class="graph-tooltip" style="display:none;"></div>

  <button id="controlsToggle" class="overlay-toggle">Controls</button>
  <div id="controlsOverlay" class="overlay">
    <h2>Controls</h2>
    <div class="control-group">
      <h3>Initial Populations</h3>
      <label for="initialPlants">Plants: <span id="initialPlantsValue">100</span></label>
      <input type="range" id="initialPlants" min="10" max="500" value="100" step="10">
      <label for="initialPrey">Prey: <span id="initialPreyValue">40</span></label>
      <input type="range" id="initialPrey" min="5" max="200" value="40" step="5">
      <label for="initialPredators">Predators: <span id="initialPredatorsValue">10</span></label>
      <input type="range" id="initialPredators" min="1" max="100" value="10" step="1">
    </div>

    <div class="control-group">
      <h3>Plant Settings</h3>
      <label for="plantReproduceRate">Plant Reproduce Rate: <span id="plantReproduceRateValue">0.0020</span></label>
      <input type="range" id="plantReproduceRate" min="0.0001" max="0.1" value="0.002" step="0.0001">
      <label for="planktonMode" class="mt-2"><input type="checkbox" id="planktonMode"> Plankton Mode (Plants
        drift)</label>
    </div>

    <div class="control-group">
      <h3>Reproduction & Health</h3>
      <label for="preyReproductionCooldown">Prey Repro Cooldown: <span
          id="preyReproductionCooldownValue">300</span></label>
      <input type="range" id="preyReproductionCooldown" min="60" max="1200" value="300" step="10">
      <label for="predatorReproductionCooldown">Predator Repro Cooldown: <span
          id="predatorReproductionCooldownValue">480</span></label>
      <input type="range" id="predatorReproductionCooldown" min="60" max="1800" value="480" step="10">

      <label for="preyMaxHealth">Prey Max Health: <span id="preyMaxHealthValue">400</span></label>
      <input type="range" id="preyMaxHealth" min="200" max="600" value="400" step="20">
      <label for="preyHealthToReproduce">Prey Health to Reproduce: <span
          id="preyHealthToReproduceValue">300</span></label>
      <input type="range" id="preyHealthToReproduce" min="150" max="580" value="300" step="10">

      <label for="predatorMaxHealth">Predator Max Health: <span id="predatorMaxHealthValue">600</span></label>
      <input type="range" id="predatorMaxHealth" min="300" max="900" value="600" step="20">
      <label for="predatorHealthToReproduce">Predator Health to Reproduce: <span
          id="predatorHealthToReproduceValue">450</span></label>
      <input type="range" id="predatorHealthToReproduce" min="250" max="880" value="450" step="10">
    </div>

    <div class="control-group">
      <h3>Prey Movement</h3>
      <label for="preyMaxSpeed">Max Speed: <span id="preyMaxSpeedValue">2.0</span></label>
      <input type="range" id="preyMaxSpeed" min="0.5" max="5.0" value="2.0" step="0.1">
      <label for="preyAgility">Agility: <span id="preyAgilityValue">0.25</span></label>
      <input type="range" id="preyAgility" min="0.05" max="0.8" value="0.25" step="0.01">
      <label for="preyInertiaEffectStrength">Inertia Effect: <span
          id="preyInertiaEffectStrengthValue">0.02</span></label>
      <input type="range" id="preyInertiaEffectStrength" min="0.0" max="0.2" value="0.02" step="0.005">
      <label for="preyTurnSpeedPenaltyFactor">Turn Penalty: <span
          id="preyTurnSpeedPenaltyFactorValue">0.05</span></label>
      <input type="range" id="preyTurnSpeedPenaltyFactor" min="0.0" max="0.3" value="0.05" step="0.01">
    </div>

    <div class="control-group">
      <h3>Predator Movement</h3>
      <label for="predatorMaxSpeed">Max Speed: <span id="predatorMaxSpeedValue">3.0</span></label>
      <input type="range" id="predatorMaxSpeed" min="0.8" max="6.0" value="3.0" step="0.1">
      <label for="predatorAgility">Agility: <span id="predatorAgilityValue">0.15</span></label>
      <input type="range" id="predatorAgility" min="0.03" max="0.6" value="0.15" step="0.01">
      <label for="predatorInertiaEffectStrength">Inertia Effect: <span
          id="predatorInertiaEffectStrengthValue">0.08</span></label>
      <input type="range" id="predatorInertiaEffectStrength" min="0.0" max="0.3" value="0.08" step="0.005">
      <label for="predatorTurnSpeedPenaltyFactor">Turn Penalty: <span
          id="predatorTurnSpeedPenaltyFactorValue">0.20</span></label>
      <input type="range" id="predatorTurnSpeedPenaltyFactor" min="0.0" max="0.5" value="0.20" step="0.01">
    </div>

    <div class="control-group">
      <h3>Hunger Rates</h3>
      <label for="preyHungerRate">Prey Hunger Rate: <span id="preyHungerRateValue">0.5</span></label>
      <input type="range" id="preyHungerRate" min="0.1" max="1.5" value="0.5" step="0.05">
      <label for="predatorHungerRate">Predator Hunger Rate: <span id="predatorHungerRateValue">0.8</span></label>
      <input type="range" id="predatorHungerRate" min="0.2" max="2.0" value="0.8" step="0.05">
    </div>

    <div class="control-group">
      <h3>Simulation Modes & Visuals</h3>
      <label for="preyKillPredatorsMode"><input type="checkbox" id="preyKillPredatorsMode"> Prey Can Kill
        Predators</label>
      <label for="showTargetLines"><input type="checkbox" id="showTargetLines"> Show Target Lines</label>
      <label for="simulationSpeed" class="mt-2">Sim Speed: <span id="simulationSpeedValue">1.0</span>x</label>
      <input type="range" id="simulationSpeed" min="0.1" max="20.0" value="1.0" step="0.1">
    </div>
    <div class="control-group">
      <h3>Data Management</h3>
      <button id="exportRunsButton" class="btn" style="--btn-bg:hsl(var(--base-hue),40%,45%);--btn-bg-hover:hsl(var(--base-hue),40%,55%);">Export
        Runs Data</button>
      <label for="importRunsFile"
        class="file-input-label btn">
        Import Runs Data
      </label>
      <input type="file" id="importRunsFile" accept=".json" class="hidden-file-input">
    </div>
    <button id="resetSimulation" class="btn">Reset
      Simulation</button>
    <button id="autoPilotRun" class="btn" style="--btn-bg:hsl(var(--base-hue),60%,50%);--btn-bg-hover:hsl(var(--base-hue),60%,60%);">Suggest
      & Start Next Run</button>
  </div>

  <button id="pastRunsToggleMain" class="overlay-toggle">View Past Runs & BN</button>

  <div id="currentRunInfo"
    style="position: absolute; top: 60px; left: 20px; color: var(--text-color); font-size: 0.9em; background-color: var(--ui-bg-color); padding: 5px 10px; border-radius: 5px; border: 1px solid var(--ui-border-color); opacity:0;">
    Current Run: <span id="currentRunDisplay">1</span>
    &nbsp;| Exploration: <span id="explorationFactorDisplay">0.00</span>
    <br>
    Last AP Score: <span id="autoPilotLastScoreDisplay">0</span>
    &nbsp;| Best AP Score: <span id="autoPilotBestScoreDisplay">0</span>
    &nbsp;| BN Err Avg: <span id="bnErrorAvgDisplay">0.00</span>
  </div>
  </div>


  <div id="pastRunsViewContainer" style="display: none;">
    <button id="backToSimulationButton" class="fixed top-5 right-5 btn mb-4 z-10" style="width:auto;">Back
      to Simulation</button>
    <h2 class="text-2xl font-bold mb-6 text-center mt-4">Past Runs Summary</h2>

    <div id="pastRunsSummaryListContainer" class="mb-8">
      <p id="noPastRunsMessage" class="text-center text-gray-400" style="display:none;">No past runs recorded yet.
      </p>
      <div id="pastRunsSummaryList">
        <!-- Summary items will be injected here -->
      </div>
    </div>

    <div id="pastRunDetails" style="display:none;">
      <h3 class="text-xl font-semibold mb-4 text-center">Run <span id="pastRunNumberDisplay"></span> Details
        (Score: <span id="pastRunScoreDisplay">-</span>, AP Score: <span id="pastRunAutoPilotScoreDisplay">-</span>)
      </h3>
      <div class="grid md:grid-cols-2 gap-6">
        <div class="stat-subsection bg-[hsl(var(--base-hue),15%,10%)] p-4 rounded-lg max-h-[400px] overflow-y-auto">
          <h4 class="text-lg font-medium mb-2">Parameters (Compared to initial defaults for this dataset):</h4>
          <div id="pastRunParamsDisplay" class="text-sm"></div>
        </div>
        <div class="stat-subsection bg-[hsl(var(--base-hue),15%,10%)] p-4 rounded-lg max-h-[400px] overflow-y-auto">
          <h4 class="text-lg font-medium mb-2">Statistics & BN Predictions:</h4>
          <div id="pastRunStatsDisplay" class="text-sm"></div>
        </div>
      </div>
      <div class="stat-subsection mt-6">
        <h4 class="text-lg font-medium mb-2 text-center">Population Graph (End of Run):</h4>
        <canvas id="pastPopulationGraphCanvas"></canvas>
        <div id="pastPopulationGraphLegend" class="graph-legend"></div>
      </div>
      <div class="stat-subsection mt-6">
        <h4 class="text-lg font-medium mb-2 text-center">Cumulative Graph (End of Run):</h4>
        <canvas id="pastCumulativeGraphCanvas"></canvas>
        <div id="pastCumulativeGraphLegend" class="graph-legend"></div>
      </div>
      <div class="stat-subsection mt-6">
        <h4 class="text-lg font-medium mb-2 text-center">BN Prediction Trends</h4>
        <canvas id="pastBNPredictionGraphCanvas"></canvas>
        <div id="pastBNPredictionGraphLegend" class="graph-legend"></div>
      </div>
      <div class="stat-subsection mt-6">
        <h4 class="text-lg font-medium mb-2 text-center">BN Prediction Trends - Extinction</h4>
        <canvas id="pastBNPredictionExtinctionGraphCanvas"></canvas>
        <div id="pastBNPredictionExtinctionGraphLegend" class="graph-legend"></div>
      </div>
      <div class="stat-subsection mt-6">
        <h4 class="text-lg font-medium mb-2 text-center">BN Prediction Trends - Growth</h4>
        <canvas id="pastBNPredictionGrowthGraphCanvas"></canvas>
        <div id="pastBNPredictionGrowthGraphLegend" class="graph-legend"></div>
      </div>
      <div class="stat-subsection mt-6">
        <h4 class="text-lg font-medium mb-2 text-center">BN Prediction Trends - Starvation Risk</h4>
        <canvas id="pastBNPredictionStarvationGraphCanvas"></canvas>
        <div id="pastBNPredictionStarvationGraphLegend" class="graph-legend"></div>
      </div>
    </div>

    <div id="bayesianNetworkVisualizationContainer" class="mt-8" style="display:none;">
      <h3 class="text-xl font-semibold mb-4 text-center">Bayesian Network Structure</h3>
        <canvas id="bayesianNetworkVisualizationCanvas"></canvas>
        <div class="mt-2 text-center">
          <button id="exportBNPngButton" class="btn" style="max-width:150px;display:inline-block;margin-right:4px;">Export PNG</button>
          <button id="exportBNSvgButton" class="btn" style="max-width:150px;display:inline-block;">Export SVG</button>
        </div>
        <div id="bnLegend" class="graph-legend mt-3 text-xs">
          <!-- Legend items will be injected here by JS -->
        </div>
    </div>

  </div>


  <script>
    // --- Global Variables & Configuration ---
    const SIM_DATA_VERSION = 1.7; // Incremented for animation state refactor
    const DOM_ELEMENTS = {};

    const CSS_VARS = {
      BASE_HUE: '--base-hue', BG_COLOR: '--bg-color', TEXT_COLOR: '--text-color',
      TEXT_COLOR_DARKER: '--text-color-darker',
      PLANT_COLOR: '--plant-color', PREY_COLOR: '--prey-color', PREDATOR_COLOR: '--predator-color',
      PREDATOR_MOBBED_COLOR: '--predator-mobbed-color', GRAPH_GRID_COLOR: '--graph-grid-color',
      GRAPH_PREY_PRED_DEATH_COLOR: '--graph-prey-pred-death-color',
      GRAPH_PREY_STARV_DEATH_COLOR: '--graph-prey-starv-death-color',
      GRAPH_PRED_STARV_DEATH_COLOR: '--graph-pred-starv-death-color',
      GRAPH_PRED_MOB_DEATH_COLOR: '--graph-pred-mob-death-color',
      GRAPH_PLANT_BIRTH_COLOR: '--graph-plant-birth-color',
      GRAPH_PLANTS_CONSUMED_COLOR: '--graph-plants-consumed-color',
      GRAPH_PREY_BIRTH_COLOR: '--graph-prey-birth-color',
      GRAPH_PREDATOR_BIRTH_COLOR: '--graph-predator-birth-color',
      GRAPH_TOTAL_PREY_DEATH_COLOR: '--graph-total-prey-death-color',
      GRAPH_TOTAL_PREDATOR_DEATH_COLOR: '--graph-total-predator-death-color',
      BN_NODE_PARAM_BG: '--bn-node-param-bg', BN_NODE_OUTCOME_BG: '--bn-node-outcome-bg',
      BN_NODE_BORDER: '--bn-node-border', BN_EDGE_COLOR: '--bn-edge-color',
      BN_ARROWHEAD_COLOR: '--bn-arrowhead-color',
      BN_EDGE_COLOR_POSITIVE: '--bn-edge-color-positive',
      BN_EDGE_COLOR_NEGATIVE: '--bn-edge-color-negative',
      BN_GROUP_PLANT: '--bn-group-plant', BN_GROUP_PREY: '--bn-group-prey',
      BN_GROUP_PREDATOR: '--bn-group-predator', BN_GROUP_DERIVED: '--bn-group-derived',
      BN_GROUP_OUTCOME: '--bn-group-outcome',
    };

    const BN_NODE_NAMES = {
      PREY_EXTINCTION: 'PreyExtinction', PREDATOR_EXTINCTION: 'PredatorExtinction',
      FAVORABLE_GROWTH_PLANT: 'FavorableGrowthPlant',
      FAVORABLE_GROWTH_PREY: 'FavorableGrowthPrey',
      FAVORABLE_GROWTH_PREDATOR: 'FavorableGrowthPredator',
      PREY_STARVATION_RISK: 'PreyStarvationRisk',
      PREDATOR_STARVATION_RISK: 'PredatorStarvationRisk',
      DERIVED_PREY_TO_PRED_RATIO: 'DerivedPreyToPredRatio',
      DERIVED_PLANT_TO_PREY_RATIO: 'DerivedPlantToPreyRatio',
      DERIVED_PREY_REPRO_HEALTH_RATIO: 'DerivedPreyReproHealthRatio',
      DERIVED_PRED_REPRO_HEALTH_RATIO: 'DerivedPredReproHealthRatio',
      DERIVED_RELATIVE_PREY_SPEED: 'DerivedRelativePreySpeed',
      DERIVED_PREY_ENERGY_BUDGET: 'DerivedPreyEnergyBudget',
      DERIVED_PREDATOR_CHASE_SUCCESS: 'DerivedPredatorChaseSuccess',
      DERIVED_PREY_REPRODUCTIVE_POTENTIAL: 'DerivedPreyReproductivePotential',
      DERIVED_PREDATOR_REPRODUCTIVE_POTENTIAL: 'DerivedPredatorReproductivePotential',
    };


    let canvas, ctx, populationGraphCanvas, populationGraphCtx, cumulativeGraphCanvas, cumulativeGraphCtx;
    let pastPopulationGraphCanvas, pastPopulationGraphCtx, pastCumulativeGraphCanvas, pastCumulativeGraphCtx;
    let bnVisualizationCanvas, bnVisualizationCtx;
    let bnPredictionGraphCanvas, bnPredictionGraphCtx;
    let bnPredictionExtinctionGraphCanvas, bnPredictionExtinctionGraphCtx;
    let bnPredictionGrowthGraphCanvas, bnPredictionGrowthGraphCtx;
    let bnPredictionStarvationGraphCanvas, bnPredictionStarvationGraphCtx;
    let bnPredictionErrorGraphCanvas, bnPredictionErrorGraphCtx;
    let pastBNPredictionGraphCanvas, pastBNPredictionGraphCtx;
    let pastBNPredictionExtinctionGraphCanvas, pastBNPredictionExtinctionGraphCtx;
    let pastBNPredictionGrowthGraphCanvas, pastBNPredictionGrowthGraphCtx;
    let pastBNPredictionStarvationGraphCanvas, pastBNPredictionStarvationGraphCtx;
    let bnLastNodePositions = {};
    let simulationViewContainer, pastRunsViewContainer, bnVisualizationContainer;
    let graphTooltip;

    function getNodeGroup(name) {
      const lower = name.toLowerCase();
      if (lower.includes('plant')) return 'plant';
      if (lower.includes('prey')) return 'prey';
      if (lower.includes('predator')) return 'predator';
      if (lower.startsWith('derived')) return 'derived';
      if (lower.includes('extinction') || lower.includes('favorablegrowth') || lower.includes('starvationrisk')) return 'outcome';
      return 'other';
    }

    let currentRunNumber = 1;
    let completedRuns = [];
    let currentRunFrameCounter = 0;
    let currentRunDeathFrames = { plant: null, prey: null, predator: null };
    let initialConfigSnapshot;

    let bnPredictionsForNextRun = { extinction: null, growth: null, starvationRisk: null };

    let simulationIsActive = true;
    let gameLoopRunning = false;

    let entities = [];
    let plants = [];
    let prey = [];
    let predators = [];

    let animationFrameId;
    let lastTimestamp = 0;
    let fps = 0;
    const fpsHistory = [];
    const fpsHistoryLength = 20;

    const SIMULATION_FIXED_STEP = 1 / 60;
    let simulationTimeAccumulator = 0;
    const MAX_SIMULATION_STEPS_PER_FRAME = 10;

    const populationHistory = {
      plants: [], prey: [], predators: [],
      preyPredationDeaths: [], preyStarvationDeaths: [],
      predatorStarvationDeaths: [], predatorMobbingDeaths: [],
      maxLength: 200
    };
    const cumulativeHistory = {
      plantBirths: [], preyBirths: [], predatorBirths: [],
      totalPreyDeaths: [], totalPredatorDeaths: [],
      plantsConsumed: [],
      maxLength: 200
    };

    const bnPredictionHistory = { // New history object for BN predictions
      plantExtinctionProb: [],
      preyExtinctionProb: [],
      predatorExtinctionProb: [],
      favorableGrowthPlantProb: [],
      favorableGrowthPreyProb: [],
      favorableGrowthPredatorProb: [],
      preyStarvationRiskProb: [],
      predatorStarvationRiskProb: [],
      maxLength: 200
    };

    const bnPredictionErrorHistory = {
      errors: [],
      maxLength: 200
    };

    let historyUpdateCounter = 0;
    const historyUpdateInterval = 30; // Update graphs every 30 simulation steps (0.5 seconds at 60FPS)

    let bnUpdateCounter = 0; // New counter for BN updates
    const bnUpdateInterval = historyUpdateInterval * 2; // Update BN predictions every 60 sim steps (e.g., once per second)

    let totalPlantBirths = 0, totalPlantsConsumed = 0;
    let totalPreyDeathsByPredation = 0, totalPreyDeathsByStarvation = 0;
    let totalPredatorDeathsByStarvation = 0, totalPredatorDeathsByMobbing = 0;
    let totalPreyBirths = 0, totalPredatorBirths = 0;

    // These track deaths *within* a historyUpdateInterval for the graph
    let intervalPreyPredDeaths = 0, intervalPreyStarvDeaths = 0;
    let intervalPredStarvDeaths = 0, intervalPredMobDeaths = 0;

    let autoPilotStats = {
      bestScoreEver: -Infinity,
      stagnationCounter: 0,
      lastScore: 0,
      lastGpVariance: 0,
      bnPredictionErrorAvg: 0,
      bnPredictionErrorCount: 0,
      modelUncertainty: 0,
    };
    function resetAutoPilotStats() {
      autoPilotStats.bestScoreEver = -Infinity;
      autoPilotStats.stagnationCounter = 0;
      autoPilotStats.lastScore = 0;
      autoPilotStats.lastGpVariance = 0;
      autoPilotStats.bnPredictionErrorAvg = 0;
      autoPilotStats.bnPredictionErrorCount = 0;
      autoPilotStats.modelUncertainty = 0;
      if (DOM_ELEMENTS.explorationFactorDisplay)
        DOM_ELEMENTS.explorationFactorDisplay.textContent = '0.00';
      updateAutoPilotStatsDisplay();
    }

    const BN_ERROR_HISTORY_LENGTH = 20;
    let bnPredictionErrors = [];
    function getBnErrorAverage() {
      if (bnPredictionErrors.length === 0) return 0.5;
      return bnPredictionErrors.reduce((a, b) => a + b, 0) / bnPredictionErrors.length;
    }

    let simBayesianNetwork = null;
    let bnPreyExtinctionCPTCounters = {}, bnPredatorExtinctionCPTCounters = {};
    let bnFavorableGrowthPlantCPTCounters = {}, bnFavorableGrowthPreyCPTCounters = {};
    let bnFavorableGrowthPredatorCPTCounters = {};
    let bnPreyStarvationRiskCPTCounters = {}, bnPredatorStarvationRiskCPTCounters = {};


    const BN_DEFAULT_BIN_COUNT = 3; // Default number of bins for discretizing continuous parameters
    const BN_LAPLACE_SMOOTHING = 1; // Laplace smoothing value for CPTs
    const BN_AUTOPILOT_PREDICTION_THRESHOLD = 0.80; // For BN scoring, how confident for "favorable growth"

    const BN_MAX_BIN_COUNT = 6; // Upper limit for adaptive binning
    const BN_BIN_EXPAND_RUN_THRESHOLD = 30; // Runs needed to add another bin
    let bnCurrentBinCount = BN_DEFAULT_BIN_COUNT; // Tracks the active bin count

    const AUTOPILOT_CANDIDATE_POOL_SIZE = 1000;
    const AUTOPILOT_PROPORTION_PERTURB = 0.5;
    const AUTOPILOT_PROPORTION_RANDOM = 0.2;
    const AUTOPILOT_PROPORTION_CROSSOVER = 0.2;
    const AUTOPILOT_PROPORTION_PERTURB_RESET = 0.1; // Perturb but also reset some params to initial/random


    // --- Bayesian Network Classes (Unchanged) ---
    class BayesianNode {
      constructor(name, type = 'discrete', options = {}) {
        this.name = name;
        this.type = type; // 'discrete' or 'continuous'
        this.parents = options.parents || [];
        this.children = [];
        this.cpt = {}; // For discrete nodes
        this.continuousParams = {}; // For continuous nodes
        this.config = options; // Store original config for discretization if needed

        if (type === 'discrete') {
          this.states = options.states || [];
        } else if (type === 'continuous') {
          this.min = options.min === undefined ? 0 : options.min;
          this.max = options.max === undefined ? 1 : options.max;
          this.dependencyType = options.dependencyType || 'linear'; // 'linear', 'none'
        }

        // Add this node as child to all parents
        this.parents.forEach(parent => {
          if (!parent.children.includes(this)) {
            parent.children.push(this);
          }
        });
      }

      setCPT(cpt) {
        if (this.type !== 'discrete') {
          throw new Error('CPT only applies to discrete nodes');
        }
        this.cpt = cpt;
      }

      setContinuousParams(params) {
        if (this.type !== 'continuous') {
          throw new Error('Continuous parameters only apply to continuous nodes');
        }
        this.continuousParams = params;
      }

      getProbability(state, parentStates = {}) {
        if (this.type !== 'discrete') {
          throw new Error('getProbability only applies to discrete nodes');
        }

        if (this.parents.length === 0) {
          return this.cpt[state] || 0;
        }

        const key = this.parents.map(parent => parentStates[parent.name]).join(',');
        const probabilities = this.cpt[key];

        if (!probabilities) {
          // console.warn(`BN: CPT key '${key}' for node '${this.name}' not found. Using uniform prior.`);
          return 1 / this.states.length; // Uniform prior if CPT entry missing
        }
        return probabilities[state] || 0;
      }

      sampleContinuous(parentValues = {}) {
        if (this.type !== 'continuous') {
          throw new Error('sampleContinuous only applies to continuous nodes');
        }
        // Simple uniform sampling for now if used, actual logic depends on model
        if (this.parents.length === 0 || this.dependencyType === 'none') {
          return Math.random() * (this.max - this.min) + this.min;
        }

        // Example for linear dependency (can be expanded)
        if (this.dependencyType === 'linear') {
          return this.sampleLinearDependency(parentValues);
        }
        // Default fallback
        return Math.random() * (this.max - this.min) + this.min;
      }

      sampleLinearDependency(parentValues) {
        let baseValue = this.continuousParams.intercept !== undefined ? this.continuousParams.intercept : (this.min + this.max) / 2;
        let adjustment = 0;
        const range = this.max - this.min;
        if (range === 0) return this.min;

        for (const parent of this.parents) {
          const parentValue = parentValues[parent.name];
          if (parentValue === undefined) continue; // Or use a default/mean for parent

          const influenceParams = this.continuousParams.weights ? this.continuousParams.weights[parent.name] : null;

          if (parent.type === 'continuous') {
            const parentRange = parent.max - parent.min;
            if (parentRange === 0) continue;
            const normalizedParent = (parentValue - parent.min) / parentRange;
            const weight = influenceParams || 0; // Default weight if not specified
            adjustment += weight * normalizedParent * range;
          } else if (parent.type === 'discrete') {
            // Assume weights for discrete parent states are defined like: {state1: weight1, state2: weight2}
            const stateWeight = influenceParams ? (influenceParams[parentValue] || 0) : 0;
            adjustment += stateWeight * range;
          }
        }
        // Add some noise
        const noiseStdDev = this.continuousParams.noiseStdDev !== undefined ? this.continuousParams.noiseStdDev : range * 0.05; // 5% of range as noise
        const noise = (Math.random() - 0.5) * 2 * noiseStdDev; // Uniform noise for simplicity here

        let result = baseValue + adjustment + noise;
        return Math.max(this.min, Math.min(this.max, result)); // Clamp to node's min/max
      }


      getProbabilityDensity(value, parentValues = {}) {
        // For a simple uniform continuous node
        if (this.type !== 'continuous') throw new Error('getProbabilityDensity only applies to continuous nodes');
        if (value < this.min || value > this.max) return 0;
        if (this.max - this.min === 0) return value === this.min ? Infinity : 0; // Or handle appropriately
        return 1 / (this.max - this.min); // Uniform density
        // More complex models (e.g., Gaussian) would have different calculations here
      }

      sampleDiscrete(parentStates = {}) {
        if (this.type !== 'discrete') throw new Error('sampleDiscrete only applies to discrete nodes');

        const probabilities = {};
        let sumProbs = 0;
        for (const state of this.states) {
          const prob = this.getProbability(state, parentStates);
          probabilities[state] = prob;
          sumProbs += prob;
        }

        // Handle cases where sumProbs might not be 1 (e.g. due to missing CPT entries or floating point issues)
        if (sumProbs === 0) { // If all probabilities are zero (e.g. CPT entry missing), sample uniformly
          return this.states[Math.floor(Math.random() * this.states.length)];
        }
        if (sumProbs !== 1 && sumProbs > 0) { // Normalize if not already
          for (const state of this.states) probabilities[state] /= sumProbs;
        }

        const rand = Math.random();
        let cumulative = 0;
        for (const [state, prob] of Object.entries(probabilities)) {
          cumulative += prob;
          if (rand <= cumulative) {
            return state;
          }
        }
        return this.states[this.states.length - 1]; // Fallback, should ideally not be reached if probs sum to 1
      }
    }

    class BayesianNetwork {
      constructor() {
        this.nodes = new Map(); // Store nodes by name
      }

      addNode(node) {
        this.nodes.set(node.name, node);
      }

      getNode(name) {
        return this.nodes.get(name);
      }

      validate() {
        // Basic validation: check for cycles using DFS
        const visited = new Set();
        const visiting = new Set(); // For cycle detection in current path

        const hasCycle = (nodeName) => {
          if (visiting.has(nodeName)) return true; // Cycle detected
          if (visited.has(nodeName)) return false; // Already processed this branch

          visiting.add(nodeName);
          const node = this.nodes.get(nodeName);
          if (!node) return false; // Should not happen if graph is consistent

          for (const child of node.children) {
            if (hasCycle(child.name)) return true;
          }

          visiting.delete(nodeName);
          visited.add(nodeName);
          return false;
        };

        for (const nodeName of this.nodes.keys()) {
          if (hasCycle(nodeName)) {
            throw new Error('Network contains cycles.');
          }
        }
        // console.log("BN validation successful: No cycles found.");
      }

      // Monte Carlo Inference using simple likelihood weighting
      // `samples` controls the number of forward samples to generate.  Each
      // sample receives a weight based on the likelihood of the given evidence
      // under that sample.  Weighted counts/values are then used to estimate
      // the desired probabilities or statistics.
      monteCarloInference(queryVar, evidence = {}, samples = 1000) {
        const queryNode = this.nodes.get(queryVar);
        if (!queryNode) return { error: `Node ${queryVar} not found` };

        // Prepare accumulators
        let totalWeight = 0;
        const weightedValues = [];
        const discreteCounts = queryNode.type === 'discrete'
          ? queryNode.states.reduce((acc, s) => { acc[s] = 0; return acc; }, {})
          : null;

        for (let i = 0; i < samples; i++) {
          const sample = this.forwardSample();
          if (!sample) continue; // Should not happen with a valid network

          // Compute likelihood weight of this sample given evidence
          let weight = 1;
          for (const [eVar, eVal] of Object.entries(evidence)) {
            const eNode = this.nodes.get(eVar);
            if (!eNode) { weight = 0; break; }

            const parentVals = {};
            eNode.parents.forEach(p => { parentVals[p.name] = sample[p.name]; });

            if (eNode.type === 'discrete') {
              weight *= eNode.getProbability(eVal, parentVals);
            } else {
              weight *= eNode.getProbabilityDensity(eVal, parentVals);
            }

            if (weight === 0) break; // Early exit if impossible
          }

          if (weight === 0) continue;

          totalWeight += weight;
          const qVal = sample[queryVar];

          if (queryNode.type === 'discrete') {
            if (discreteCounts[qVal] !== undefined) {
              discreteCounts[qVal] += weight;
            }
          } else {
            weightedValues.push({ value: qVal, weight });
          }
        }

        if (totalWeight === 0) {
          return {
            type: queryNode.type,
            error: 'No samples had non-zero weight',
            samples: 0,
            distribution: queryNode.type === 'discrete'
              ? queryNode.states.reduce((acc, state) => { acc[state] = 0; return acc; }, {})
              : {},
            mean: NaN,
            stdDev: NaN
          };
        }

        if (queryNode.type === 'discrete') {
          const probabilities = {};
          for (const [state, count] of Object.entries(discreteCounts)) {
            probabilities[state] = count / totalWeight;
          }
          return { type: 'discrete', distribution: probabilities, samples };
        } else { // Continuous query variable
          const mean = weightedValues.reduce((sum, v) => sum + v.value * v.weight, 0) / totalWeight;
          const variance = weightedValues.reduce((sum, v) => sum + v.weight * Math.pow(v.value - mean, 2), 0) / totalWeight;
          const values = weightedValues.map(v => v.value);
          return {
            type: 'continuous',
            mean,
            variance,
            stdDev: Math.sqrt(variance),
            min: Math.min(...values),
            max: Math.max(...values),
            samples
          };
        }
      }


      forwardSample() {
        const sample = {};
        const sortedNodes = this.topologicalSort();
        if (!sortedNodes) return null; // Cycle detected or error

        for (const nodeName of sortedNodes) {
          const node = this.nodes.get(nodeName);
          if (!node) return null; // Should not happen

          const parentValues = {};
          for (const parent of node.parents) {
            if (sample[parent.name] === undefined) {
              // This case should ideally not happen if sortedNodes is correct and all parents are processed first.
              // Fallback: use a default value or midpoint if a parent's sample is missing.
              if (parent.type === 'discrete') parentValues[parent.name] = parent.states[0]; // Default to first state
              else parentValues[parent.name] = (parent.min + parent.max) / 2; // Default to midpoint
            } else {
              parentValues[parent.name] = sample[parent.name];
            }
          }

          if (node.type === 'discrete') {
            sample[nodeName] = node.sampleDiscrete(parentValues);
          } else { // Continuous
            sample[nodeName] = node.sampleContinuous(parentValues);
          }
        }
        return sample;
      }


      topologicalSort() {
        const L = []; // Sorted list
        const S = new Set(); // Nodes with no incoming edges
        const G = new Map(); // Adjacency list (nodeName -> Set of childNodeNames)
        const inDegree = new Map(); // nodeName -> count of incoming edges

        this.nodes.forEach((node, nodeName) => {
          G.set(nodeName, new Set(node.children.map(c => c.name)));
          inDegree.set(nodeName, node.parents.length);
          if (node.parents.length === 0) {
            S.add(nodeName);
          }
        });

        while (S.size > 0) {
          const n = S.values().next().value; // Pick a node from S
          S.delete(n);
          L.push(n);

          if (G.has(n)) {
            const childrenOfN = Array.from(G.get(n)); // Iterate over a copy
            for (const m of childrenOfN) {
              inDegree.set(m, inDegree.get(m) - 1);
              if (inDegree.get(m) === 0) {
                S.add(m);
              }
            }
          }
        }

        if (L.length !== this.nodes.size) {
          console.error("BN Topological Sort: Cycle detected or graph error.", L.length, this.nodes.size);
          return null; // Graph has a cycle
        }
        return L;
      }

      // Direct CPT lookup for discrete nodes given parent states
      getDiscreteNodeProbability(nodeName, targetState, discreteParentStates) {
        const node = this.nodes.get(nodeName);
        if (!node || node.type !== 'discrete') {
          // console.warn(`Node ${nodeName} not found or not discrete for CPT lookup.`);
          return node ? 1 / (node.states?.length || 1) : 0.5; // Default or uniform if node exists but CPT fails
        }
        return node.getProbability(targetState, discreteParentStates);
      }

      query(queryVar, evidence = {}) {
        // For complex networks with continuous variables, Monte Carlo is generally needed.
        // For purely discrete networks, variable elimination or other exact methods could be used,
        // but Monte Carlo (like Likelihood Weighting) can handle mixed types.
        const hasContinuous = Array.from(this.nodes.values()).some(node => node.type === 'continuous');
        if (hasContinuous) {
          return this.monteCarloInference(queryVar, evidence);
        }

        // Fallback for simple discrete-only query (could be more sophisticated)
        const queryNode = this.nodes.get(queryVar);
        if (!queryNode || queryNode.type !== 'discrete') {
          return { error: `Node ${queryVar} not found or not discrete` };
        }
        // Using Monte Carlo even for discrete as a general approach here
        return this.monteCarloInference(queryVar, evidence, 500); // Fewer samples for simpler cases perhaps
      }
    }

    // --- Gaussian Process / Bayesian Optimization Helper (Simplified) ---
    class SimpleGaussianProcess {
      constructor(tunableParamsListForNormalization) {
        this.observations = []; // {params: {}, normalizedParams: {}, score: number}[]
        this.tunableParamsList = tunableParamsListForNormalization; // To know min/max for normalization

        // Tunable GP parameters
        this.MIN_OBS_FOR_GP_ESTIMATE = 15; // Min observations before GP is considered reliable
        this.RBF_GAMMA = 0.7; // Width of RBF kernel (higher = more localized influence)
        this.K_NEIGHBORS_FOR_VARIANCE = Math.min(7, this.MIN_OBS_FOR_GP_ESTIMATE - 1); // K for k-NN distance based variance
        this.GP_VARIANCE_DIST_SENSITIVITY = 0.30; // How sensitive variance is to k-NN distance
        this.GP_MIN_VARIANCE = 0.02; // Minimum exploration variance
        this.GP_MAX_VARIANCE = 1.0; // Maximum exploration variance (e.g., for completely unknown areas)
      }

      _normalizeParams(params) {
        const normalized = {};
        this.tunableParamsList.forEach(pConf => {
          const val = params[pConf.configKey];
          // Handle boolean flags explicitly if they are part of params
          if (typeof val === 'boolean') {
            normalized[pConf.configKey] = val ? 1.0 : 0.0;
            return;
          }
          if (val === undefined) {
            // console.warn(`GP Normalization: Param ${pConf.configKey} undefined. Using 0.5.`);
            normalized[pConf.configKey] = 0.5; // Default if param missing
            return;
          }
          const range = pConf.max - pConf.min;
          normalized[pConf.configKey] = range > 0 ? Math.max(0, Math.min(1, (val - pConf.min) / range)) : 0.5;
        });
        return normalized;
      }

      _euclideanDistance(normParams1, normParams2) {
        let sumSqDiff = 0;
        let dims = 0;
        for (const key in normParams1) {
          if (normParams2.hasOwnProperty(key)) {
            const diff = normParams1[key] - normParams2[key];
            sumSqDiff += diff * diff;
            dims++;
          }
        }
        return dims > 0 ? Math.sqrt(sumSqDiff) : 0;
      }

      addObservation(params, score) {
        const normalizedParams = this._normalizeParams(params);
        this.observations.push({ params, normalizedParams, score });
      }

      predict(targetParams) {
        const normalizedTargetParams = this._normalizeParams(targetParams);

        if (this.observations.length < this.MIN_OBS_FOR_GP_ESTIMATE) {
          // Not enough data, return high variance and average score (or 0)
          const avgScore = this.observations.length > 0
            ? this.observations.reduce((sum, obs) => sum + obs.score, 0) / this.observations.length
            : 0; // Default score if no observations
          return { mean: avgScore, variance: this.GP_MAX_VARIANCE };
        }

        let weightedScoreSum = 0;
        let weightSum = 0;
        const distances = [];

        this.observations.forEach(obs => {
          const dist = this._euclideanDistance(normalizedTargetParams, obs.normalizedParams);
          distances.push(dist);
          // RBF kernel for weighting: influence of observations drops with distance
          const weight = Math.exp(-this.RBF_GAMMA * dist * dist * this.tunableParamsList.length); // Scale gamma by num dimensions
          weightedScoreSum += weight * obs.score;
          weightSum += weight;
        });

        // Predicted mean is the weighted average of observed scores
        const mean = (weightSum > 1e-9) ? weightedScoreSum / weightSum : this.observations.reduce((sum, obs) => sum + obs.score, 0) / this.observations.length;


        // Estimate variance based on distance to k-nearest neighbors in parameter space
        let variance;
        if (distances.length > 0 && this.K_NEIGHBORS_FOR_VARIANCE > 0 && distances.length >= this.K_NEIGHBORS_FOR_VARIANCE) {
          distances.sort((a, b) => a - b);
          const kthNeighborDist = distances[this.K_NEIGHBORS_FOR_VARIANCE - 1]; // k is 0-indexed
          const maxPossibleDistForTunable = Math.sqrt(this.tunableParamsList.length);
          variance = Math.min(this.GP_MAX_VARIANCE, kthNeighborDist / (maxPossibleDistForTunable * this.GP_VARIANCE_DIST_SENSITIVITY + 1e-9));
        } else {
          variance = this.GP_MAX_VARIANCE;
        }

        if (weightSum > 1e-9) {
          let sqErrSum = 0;
          this.observations.forEach(obs => {
            const dist = this._euclideanDistance(normalizedTargetParams, obs.normalizedParams);
            const weight = Math.exp(-this.RBF_GAMMA * dist * dist * this.tunableParamsList.length);
            const diff = obs.score - mean;
            sqErrSum += weight * diff * diff;
          });
          const weightedVar = sqErrSum / weightSum;
          variance = Math.max(variance, weightedVar);
        }

        if (weightSum < 1e-5 && this.observations.length >= this.MIN_OBS_FOR_GP_ESTIMATE) {
          variance = Math.min(this.GP_MAX_VARIANCE, variance + 0.35);
        }

        return { mean: mean, variance: Math.max(this.GP_MIN_VARIANCE, Math.min(this.GP_MAX_VARIANCE, variance)) };
      }
    }
    let gpOptimizer = null;

    // --- BN Helper Functions ---
    function discretizeContinuousValue(value, min, max, numBins) { if (value <= min) return 0; if (value >= max) return numBins - 1; const binWidth = (max - min) / numBins; if (binWidth === 0) return 0; const binIndex = Math.floor((value - min) / binWidth); return Math.min(binIndex, numBins - 1); }
    function getParamKeyForCPT(paramValues, parentParamConfigs) { let keyParts = []; for (const pConf of parentParamConfigs) { const val = paramValues[pConf.configKey]; if (val === undefined) { /*console.warn(`Undefined value for ${pConf.configKey} in getParamKeyForCPT`);*/ keyParts.push('NaN'); continue; } const binIndex = discretizeContinuousValue(val, pConf.min, pConf.max, pConf.binCount || BN_DEFAULT_BIN_COUNT); keyParts.push(`b${binIndex}`); } return keyParts.join(','); }

    const bnParamNodesConfigBase = [ // Base parameters directly from config/sliders
      { name: 'initialPlants', configKey: 'initialPlants', type: 'continuous', isTunable: true, binCount: BN_DEFAULT_BIN_COUNT },
      { name: 'initialPrey', configKey: 'initialPrey', type: 'continuous', isTunable: true, binCount: BN_DEFAULT_BIN_COUNT },
      { name: 'initialPredators', configKey: 'initialPredators', type: 'continuous', isTunable: true, binCount: BN_DEFAULT_BIN_COUNT },
      { name: 'plantReproduceRate', configKey: 'plantReproduceRate', type: 'continuous', isTunable: true, binCount: BN_DEFAULT_BIN_COUNT },
      { name: 'preyReproductionCooldown', configKey: 'preyReproductionCooldown', type: 'continuous', isTunable: true, binCount: BN_DEFAULT_BIN_COUNT },
      { name: 'predatorReproductionCooldown', configKey: 'predatorReproductionCooldown', type: 'continuous', isTunable: true, binCount: BN_DEFAULT_BIN_COUNT },
      { name: 'preyMaxHealth', configKey: 'preyMaxHealth', type: 'continuous', isTunable: true, binCount: BN_DEFAULT_BIN_COUNT },
      { name: 'preyHealthToReproduce', configKey: 'preyHealthToReproduce', type: 'continuous', isTunable: true, binCount: BN_DEFAULT_BIN_COUNT },
      { name: 'predatorMaxHealth', configKey: 'predatorMaxHealth', type: 'continuous', isTunable: true, binCount: BN_DEFAULT_BIN_COUNT },
      { name: 'predatorHealthToReproduce', configKey: 'predatorHealthToReproduce', type: 'continuous', isTunable: true, binCount: BN_DEFAULT_BIN_COUNT },
      { name: 'preyMaxSpeed', configKey: 'preyMaxSpeed', type: 'continuous', isTunable: true, binCount: BN_DEFAULT_BIN_COUNT },
      { name: 'preyAgility', configKey: 'preyAgility', type: 'continuous', isTunable: true, binCount: BN_DEFAULT_BIN_COUNT },
      // preyInertiaEffectStrength, preyTurnSpeedPenaltyFactor (omitted as less critical for high-level BN outcomes, could be added)
      { name: 'predatorMaxSpeed', configKey: 'predatorMaxSpeed', type: 'continuous', isTunable: true, binCount: BN_DEFAULT_BIN_COUNT },
      { name: 'predatorAgility', configKey: 'predatorAgility', type: 'continuous', isTunable: true, binCount: BN_DEFAULT_BIN_COUNT },
      // predatorInertiaEffectStrength, predatorTurnSpeedPenaltyFactor (omitted)
      { name: 'preyHungerRate', configKey: 'preyHungerRate', type: 'continuous', isTunable: true, binCount: BN_DEFAULT_BIN_COUNT },
      { name: 'predatorHungerRate', configKey: 'predatorHungerRate', type: 'continuous', isTunable: true, binCount: BN_DEFAULT_BIN_COUNT },
      // planktonMode, preyKillPredatorsMode are boolean, handled slightly differently if needed as parents, or implicitly via their effect on outcomes
    ];

    const bnDerivedParamNodesConfig = [ // Derived features, calculated from base params
      {
        name: BN_NODE_NAMES.DERIVED_PREY_TO_PRED_RATIO, configKey: BN_NODE_NAMES.DERIVED_PREY_TO_PRED_RATIO, type: 'continuous', min: 0, max: 50, default: 5, isTunable: false, binCount: BN_DEFAULT_BIN_COUNT, parentConfigKeys: ['initialPrey', 'initialPredators'],
        calculate: (p, globalConf) => (p.initialPredators > 0 ? p.initialPrey / p.initialPredators : p.initialPrey * 2)
      }, // High ratio if no preds
      {
        name: BN_NODE_NAMES.DERIVED_PLANT_TO_PREY_RATIO, configKey: BN_NODE_NAMES.DERIVED_PLANT_TO_PREY_RATIO, type: 'continuous', min: 0, max: 50, default: 5, isTunable: false, binCount: BN_DEFAULT_BIN_COUNT, parentConfigKeys: ['initialPlants', 'initialPrey'],
        calculate: (p, globalConf) => (p.initialPrey > 0 ? p.initialPlants / p.initialPrey : p.initialPlants * 2)
      }, // High ratio if no prey
      {
        name: BN_NODE_NAMES.DERIVED_PREY_REPRO_HEALTH_RATIO, configKey: BN_NODE_NAMES.DERIVED_PREY_REPRO_HEALTH_RATIO, type: 'continuous', min: 0.25, max: 1.0, default: 0.75, isTunable: false, binCount: BN_DEFAULT_BIN_COUNT, parentConfigKeys: ['preyHealthToReproduce', 'preyMaxHealth'],
        calculate: (p, globalConf) => (p.preyMaxHealth > 0 ? Math.max(0.25, Math.min(1.0, p.preyHealthToReproduce / p.preyMaxHealth)) : 0.75)
      },
      {
        name: BN_NODE_NAMES.DERIVED_PRED_REPRO_HEALTH_RATIO, configKey: BN_NODE_NAMES.DERIVED_PRED_REPRO_HEALTH_RATIO, type: 'continuous', min: 0.25, max: 1.0, default: 0.75, isTunable: false, binCount: BN_DEFAULT_BIN_COUNT, parentConfigKeys: ['predatorHealthToReproduce', 'predatorMaxHealth'],
        calculate: (p, globalConf) => (p.predatorMaxHealth > 0 ? Math.max(0.25, Math.min(1.0, p.predatorHealthToReproduce / p.predatorMaxHealth)) : 0.75)
      },
      {
        name: BN_NODE_NAMES.DERIVED_RELATIVE_PREY_SPEED, configKey: BN_NODE_NAMES.DERIVED_RELATIVE_PREY_SPEED, type: 'continuous', min: 0.2, max: 3.0, default: 1.0, isTunable: false, binCount: BN_DEFAULT_BIN_COUNT, parentConfigKeys: ['preyMaxSpeed', 'predatorMaxSpeed'],
        calculate: (p, globalConf) => (p.predatorMaxSpeed > 0 ? p.preyMaxSpeed / p.predatorMaxSpeed : p.preyMaxSpeed)
      },

      // More advanced derived features
      {
        name: BN_NODE_NAMES.DERIVED_PREY_ENERGY_BUDGET, configKey: BN_NODE_NAMES.DERIVED_PREY_ENERGY_BUDGET, type: 'continuous', min: 0, max: 5000, default: 500, isTunable: false, binCount: BN_DEFAULT_BIN_COUNT, parentConfigKeys: ['preyHealthGainFromPlant', 'preyHungerRate', 'plantReproduceRate', 'initialPrey', 'initialPlants'],
        calculate: (p, globalConf) => (globalConf.preyHealthGainFromPlant / Math.max(0.1, p.preyHungerRate)) * (p.plantReproduceRate / Math.max(0.01, p.initialPrey / Math.max(1, p.initialPlants)))
      }, // Health gain per hunger * plant growth per prey
      {
        name: BN_NODE_NAMES.DERIVED_PREDATOR_CHASE_SUCCESS, configKey: BN_NODE_NAMES.DERIVED_PREDATOR_CHASE_SUCCESS, type: 'continuous', min: 0.05, max: 20, default: 1, isTunable: false, binCount: BN_DEFAULT_BIN_COUNT, parentConfigKeys: ['predatorMaxSpeed', 'preyMaxSpeed', 'predatorAgility', 'preyAgility'],
        calculate: (p, globalConf) => (p.predatorMaxSpeed * p.predatorAgility) / Math.max(0.01, p.preyMaxSpeed * p.preyAgility)
      }, // Relative maneuverability and speed
      {
        name: BN_NODE_NAMES.DERIVED_PREY_REPRODUCTIVE_POTENTIAL, configKey: BN_NODE_NAMES.DERIVED_PREY_REPRODUCTIVE_POTENTIAL, type: 'continuous', min: -20, max: 200, default: 10, isTunable: false, binCount: BN_DEFAULT_BIN_COUNT, parentConfigKeys: ['preyMaxHealth', 'preyReproductionCooldown', 'preyHungerRate'],
        calculate: (p, globalConf) => (p.preyMaxHealth - globalConf.preyReproductionCost) / Math.max(1, p.preyReproductionCooldown * p.preyHungerRate)
      }, // Net health after repro / time to next repro considering hunger
      {
        name: BN_NODE_NAMES.DERIVED_PREDATOR_REPRODUCTIVE_POTENTIAL, configKey: BN_NODE_NAMES.DERIVED_PREDATOR_REPRODUCTIVE_POTENTIAL, type: 'continuous', min: -20, max: 200, default: 10, isTunable: false, binCount: BN_DEFAULT_BIN_COUNT, parentConfigKeys: ['predatorMaxHealth', 'predatorReproductionCooldown', 'predatorHungerRate'],
        calculate: (p, globalConf) => (p.predatorMaxHealth - globalConf.predatorReproductionCost) / Math.max(1, p.predatorReproductionCooldown * p.predatorHungerRate)
      },
    ];
    function applyBinCountToConfigs(count) {
      bnParamNodesConfigBase.forEach(c => c.binCount = count);
      bnDerivedParamNodesConfig.forEach(c => c.binCount = count);
    }

    function adaptBNBinCountIfNeeded() {
      const desired = Math.min(BN_MAX_BIN_COUNT,
        BN_DEFAULT_BIN_COUNT + Math.floor(completedRuns.length / BN_BIN_EXPAND_RUN_THRESHOLD));
      const needRebuild = !simBayesianNetwork || desired !== bnCurrentBinCount;
      if (!needRebuild) return;

      bnCurrentBinCount = desired;
      applyBinCountToConfigs(bnCurrentBinCount);

      bnPreyExtinctionCPTCounters = {};
      bnPredatorExtinctionCPTCounters = {};
      bnFavorableGrowthPlantCPTCounters = {};
      bnFavorableGrowthPreyCPTCounters = {};
      bnFavorableGrowthPredatorCPTCounters = {};
      bnPreyStarvationRiskCPTCounters = {};
      bnPredatorStarvationRiskCPTCounters = {};

      initBN();

      completedRuns.forEach(run => {
        if (run.durationFrames > 30) {
          updateBNWithRunData(run);
        }
      });
    }

    applyBinCountToConfigs(bnCurrentBinCount);
    let allBnParamAndDerivedNodeConfigs = []; // Will be populated in initBN

    function getBNMinRunsForPrediction() {
      const allConfigs = [...bnParamNodesConfigBase, ...bnDerivedParamNodesConfig];
      const maxBins = Math.max(...allConfigs.map(c => c.binCount || BN_DEFAULT_BIN_COUNT));
      return maxBins * 15; // Heuristic: more bins require more runs
    }

    // Calculates derived parameters given a set of base parameters and the global config context
    function calculateDerivedParams(baseParams, fullConfigContext = config) {
      const derived = {};
      bnDerivedParamNodesConfig.forEach(dpConf => {
        derived[dpConf.configKey] = dpConf.calculate(baseParams, fullConfigContext);
      });
      return derived;
    }

    // Combines base parameters with their calculated derived parameters
    function getFullParamsWithDerived(baseParams) {
      const fullContext = { ...initialConfigSnapshot, ...baseParams }; // Ensure all config values are present
      const derived = calculateDerivedParams(fullContext, fullContext); // Pass fullContext as both base and global context
      return { ...fullContext, ...derived };
    }


    function isBNReady() { return simBayesianNetwork && completedRuns.length >= getBNMinRunsForPrediction(); }

    function initBN() {
      simBayesianNetwork = new BayesianNetwork();
      allBnParamAndDerivedNodeConfigs = []; // Reset for re-initialization (e.g. after import)

      // Create nodes for base tunable parameters
      bnParamNodesConfigBase.forEach(pConf => {
        const tunable = tunableParams.find(tp => tp.configKey === pConf.configKey);
        let min = tunable ? tunable.min : pConf.min || 0;
        let max = tunable ? tunable.max : pConf.max || 100; // Default max if not in tunableParams
        const node = new BayesianNode(pConf.name, 'continuous', { min, max });
        simBayesianNetwork.addNode(node);
        allBnParamAndDerivedNodeConfigs.push({ ...pConf, node, min, max }); // Store node ref and its config
      });

      // Create nodes for derived parameters
      bnDerivedParamNodesConfig.forEach(dpConf => {
        const parentNodes = dpConf.parentConfigKeys
          .map(key => simBayesianNetwork.getNode(bnParamNodesConfigBase.find(bc => bc.configKey === key)?.name || key)) // Find parent node by base configKey then name
          .filter(Boolean); // Filter out any not found (shouldn't happen if config is correct)
        const node = new BayesianNode(dpConf.name, 'continuous', { min: dpConf.min, max: dpConf.max, parents: parentNodes });
        simBayesianNetwork.addNode(node);
        allBnParamAndDerivedNodeConfigs.push({ ...dpConf, node }); // Store node ref and its config
      });

      // Helper to create discrete outcome nodes (Extinction, FavorableGrowth, StarvationRisk)
      const createDiscreteOutcomeNode = (outcomeNodeName, parentNamesList, countersObjRef) => {
        const parents = parentNamesList
          .map(name => simBayesianNetwork.getNode(name)) // Parents can be base or derived
          .filter(Boolean);
        const node = new BayesianNode(outcomeNodeName, 'discrete', { states: ['false', 'true'], parents });
        simBayesianNetwork.addNode(node);

        // For CPT key generation, find the config details of these parents
        const parentConfigsForCPT = allBnParamAndDerivedNodeConfigs.filter(pConf => parentNamesList.includes(pConf.name));
        initializeNodeCPT(node, parentConfigsForCPT, countersObjRef);
      };

      // Define parents for Extinction nodes (mix of base and derived)
      createDiscreteOutcomeNode(BN_NODE_NAMES.PREY_EXTINCTION,
        ['initialPrey', 'preyReproductionCooldown', 'preyHungerRate',
          BN_NODE_NAMES.DERIVED_PLANT_TO_PREY_RATIO, BN_NODE_NAMES.DERIVED_PREY_REPRO_HEALTH_RATIO,
          BN_NODE_NAMES.DERIVED_RELATIVE_PREY_SPEED, BN_NODE_NAMES.DERIVED_PREY_ENERGY_BUDGET,
          BN_NODE_NAMES.DERIVED_PREY_REPRODUCTIVE_POTENTIAL, BN_NODE_NAMES.DERIVED_PREDATOR_CHASE_SUCCESS],
        bnPreyExtinctionCPTCounters);

      createDiscreteOutcomeNode(BN_NODE_NAMES.PREDATOR_EXTINCTION,
        ['initialPredators', 'predatorReproductionCooldown', 'predatorHungerRate',
          BN_NODE_NAMES.DERIVED_PREY_TO_PRED_RATIO, BN_NODE_NAMES.DERIVED_PRED_REPRO_HEALTH_RATIO,
          BN_NODE_NAMES.DERIVED_RELATIVE_PREY_SPEED, BN_NODE_NAMES.DERIVED_PREDATOR_CHASE_SUCCESS,
          BN_NODE_NAMES.DERIVED_PREDATOR_REPRODUCTIVE_POTENTIAL, BN_NODE_NAMES.DERIVED_PREY_REPRODUCTIVE_POTENTIAL], // Prey potential affects predator food source
        bnPredatorExtinctionCPTCounters);

      // Define parents for FavorableGrowth nodes
      createDiscreteOutcomeNode(BN_NODE_NAMES.FAVORABLE_GROWTH_PLANT,
        ['initialPlants', 'plantReproduceRate', BN_NODE_NAMES.DERIVED_PLANT_TO_PREY_RATIO],
        bnFavorableGrowthPlantCPTCounters);

      createDiscreteOutcomeNode(BN_NODE_NAMES.FAVORABLE_GROWTH_PREY,
        ['initialPrey', 'preyReproductionCooldown', 'preyHungerRate',
          BN_NODE_NAMES.DERIVED_PLANT_TO_PREY_RATIO, BN_NODE_NAMES.DERIVED_PREY_REPRO_HEALTH_RATIO, 'plantReproduceRate', // Plant growth affects prey food
          BN_NODE_NAMES.DERIVED_PREY_ENERGY_BUDGET, BN_NODE_NAMES.DERIVED_PREY_REPRODUCTIVE_POTENTIAL],
        bnFavorableGrowthPreyCPTCounters);

      createDiscreteOutcomeNode(BN_NODE_NAMES.FAVORABLE_GROWTH_PREDATOR,
        ['initialPredators', 'predatorReproductionCooldown', 'predatorHungerRate',
          BN_NODE_NAMES.DERIVED_PREY_TO_PRED_RATIO, BN_NODE_NAMES.DERIVED_PRED_REPRO_HEALTH_RATIO, 'initialPrey', // Prey numbers affect predator food
          BN_NODE_NAMES.DERIVED_PREDATOR_CHASE_SUCCESS, BN_NODE_NAMES.DERIVED_PREDATOR_REPRODUCTIVE_POTENTIAL],
        bnFavorableGrowthPredatorCPTCounters);

      // Define parents for StarvationRisk nodes
      createDiscreteOutcomeNode(BN_NODE_NAMES.PREY_STARVATION_RISK,
        ['initialPrey', 'preyHungerRate', BN_NODE_NAMES.DERIVED_PREY_ENERGY_BUDGET,
          BN_NODE_NAMES.DERIVED_PLANT_TO_PREY_RATIO, 'plantReproduceRate'],
        bnPreyStarvationRiskCPTCounters);

      createDiscreteOutcomeNode(BN_NODE_NAMES.PREDATOR_STARVATION_RISK,
        ['initialPredators', 'predatorHungerRate', BN_NODE_NAMES.DERIVED_PREDATOR_CHASE_SUCCESS,
          BN_NODE_NAMES.DERIVED_PREY_TO_PRED_RATIO, 'preyReproductionCooldown', BN_NODE_NAMES.DERIVED_PREY_REPRODUCTIVE_POTENTIAL], // Prey repro affects long-term food for preds
        bnPredatorStarvationRiskCPTCounters);


      try {
        simBayesianNetwork.validate();
        console.log("Bayesian Network Initialized with derived features and starvation risk nodes.");
      } catch (e) {
        console.error("BN Validation Error:", e);
      }
    }


    // Initializes CPT for a discrete outcome node with Laplace smoothing
    function initializeNodeCPT(node, parentParamConfigsForNode, cptCounters) {
      const parentBinCounts = parentParamConfigsForNode.map(p => p.binCount || BN_DEFAULT_BIN_COUNT);
      const numParentCombinations = parentBinCounts.reduce((acc, val) => acc * val, 1);

      const currentParentBins = new Array(parentParamConfigsForNode.length).fill(0);

      for (let i = 0; i < numParentCombinations; i++) {
        // Construct CPT key from current bin combination
        const keyParts = currentParentBins.map(binIdx => `b${binIdx}`);
        const key = keyParts.join(',');

        cptCounters[key] = {}; // Initialize counters for this parent combination
        node.cpt[key] = {};   // Initialize CPT entry for this parent combination

        let totalForKeyWithSmoothing = 0;
        for (const state of node.states) {
          cptCounters[key][state] = BN_LAPLACE_SMOOTHING; // Apply Laplace smoothing
          totalForKeyWithSmoothing += BN_LAPLACE_SMOOTHING;
        }

        for (const state of node.states) {
          node.cpt[key][state] = cptCounters[key][state] / totalForKeyWithSmoothing;
        }

        // Increment to next parent bin combination (like odometer)
        let k_idx = 0;
        while (k_idx < parentParamConfigsForNode.length) {
          currentParentBins[k_idx]++;
          if (currentParentBins[k_idx] < parentBinCounts[k_idx]) break; // No carry-over
          currentParentBins[k_idx] = 0; // Reset and carry-over
          k_idx++;
        }
      }
    }

    // Updates the BN with data from a completed run
    function updateBNWithRunData(runData) {
      if (!simBayesianNetwork) return;

      const baseParams = runData.parameters; // These are the full parameters for the run
      const fullParamsWithDerived = getFullParamsWithDerived(baseParams); // Calculate derived features
      const stats = runData.statistics;
      const duration = runData.durationFrames > 0 ? runData.durationFrames : 1; // Avoid division by zero

      // Helper to update a specific outcome node
      const updateNode = (nodeName, outcomeCondition, countersObj) => {
        const node = simBayesianNetwork.getNode(nodeName);
        if (!node) { console.warn(`BN node ${nodeName} not found during update.`); return; }

        const outcome = outcomeCondition ? 'true' : 'false';
        const parentNames = node.parents.map(p => p.name);
        const parentConfigsForNode = allBnParamAndDerivedNodeConfigs.filter(pConf => parentNames.includes(pConf.name));

        updateNodeCPTFromRun(node, outcome, fullParamsWithDerived, parentConfigsForNode, countersObj);
      };

      // Update Extinction nodes
      updateNode(BN_NODE_NAMES.PREY_EXTINCTION, (stats.deathFrames.prey !== null && baseParams.initialPrey > 0), bnPreyExtinctionCPTCounters);
      updateNode(BN_NODE_NAMES.PREDATOR_EXTINCTION, (stats.deathFrames.predator !== null && baseParams.initialPredators > 0), bnPredatorExtinctionCPTCounters);

      // Update FavorableGrowth nodes (Rate-based comparison)
      updateNode(BN_NODE_NAMES.FAVORABLE_GROWTH_PLANT, (stats.totalPlantBirths / duration) > (stats.totalPlantsConsumed / duration), bnFavorableGrowthPlantCPTCounters);
      updateNode(BN_NODE_NAMES.FAVORABLE_GROWTH_PREY, (stats.totalPreyBirths / duration) > ((stats.totalPreyDeathsByPredation + stats.totalPreyDeathsByStarvation) / duration), bnFavorableGrowthPreyCPTCounters);
      updateNode(BN_NODE_NAMES.FAVORABLE_GROWTH_PREDATOR, (stats.totalPredatorBirths / duration) > ((stats.totalPredatorDeathsByStarvation + stats.totalPredatorDeathsByMobbing) / duration), bnFavorableGrowthPredatorCPTCounters);

      // Update StarvationRisk nodes (Based on proportion and rate of starvation deaths)
      const preyStarvationFraction = (stats.totalPreyDeathsByStarvation / Math.max(1, stats.totalPreyDeathsByPredation + stats.totalPreyDeathsByStarvation));
      const preyStarvationRate = (stats.totalPreyDeathsByStarvation / duration) / Math.max(1, baseParams.initialPrey); // Per capita starvation rate
      const isPreyStarvationRisk = (preyStarvationFraction > 0.70 && (stats.totalPreyDeathsByPredation + stats.totalPreyDeathsByStarvation) > 5) || // High fraction of deaths
        (preyStarvationRate > 0.003 && baseParams.initialPrey > 5 && duration > 100); // High per capita rate
      updateNode(BN_NODE_NAMES.PREY_STARVATION_RISK, isPreyStarvationRisk, bnPreyStarvationRiskCPTCounters);

      const predStarvationFraction = (stats.totalPredatorDeathsByStarvation / Math.max(1, stats.totalPredatorDeathsByStarvation + stats.totalPredatorDeathsByMobbing));
      const predStarvationRate = (stats.totalPredatorDeathsByStarvation / duration) / Math.max(1, baseParams.initialPredators);
      const isPredStarvationRisk = (predStarvationFraction > 0.70 && (stats.totalPredatorDeathsByStarvation + stats.totalPredatorDeathsByMobbing) > 2) ||
        (predStarvationRate > 0.004 && baseParams.initialPredators > 2 && duration > 100);
      updateNode(BN_NODE_NAMES.PREDATOR_STARVATION_RISK, isPredStarvationRisk, bnPredatorStarvationRiskCPTCounters);
    }

    // Updates the CPT of a single node based on one run's outcome and parameters
    function updateNodeCPTFromRun(node, outcomeState, runFullParams, parentParamConfigsForNode, cptCounters) {
      // Get relevant parameters for CPT key generation (these are the parents of the node)
      const relevantRunParamsForCPTKey = {};
      parentParamConfigsForNode.forEach(pConf => {
        relevantRunParamsForCPTKey[pConf.configKey] = runFullParams[pConf.configKey];
      });

      const key = getParamKeyForCPT(relevantRunParamsForCPTKey, parentParamConfigsForNode);

      // Initialize counter for this key if it doesn't exist
      if (!cptCounters[key]) {
        cptCounters[key] = {};
        node.states.forEach(s => cptCounters[key][s] = BN_LAPLACE_SMOOTHING);
      }
      // Ensure counter for the specific outcome state exists
      if (cptCounters[key][outcomeState] === undefined) {
        cptCounters[key][outcomeState] = BN_LAPLACE_SMOOTHING;
      }

      cptCounters[key][outcomeState]++; // Increment count for observed outcome

      // Recalculate probabilities for this CPT entry
      let totalForKeyWithSmoothing = 0;
      for (const state of node.states) {
        totalForKeyWithSmoothing += (cptCounters[key][state] || BN_LAPLACE_SMOOTHING); // Use smoothing if a state somehow wasn't init'd
      }

      if (!node.cpt[key]) node.cpt[key] = {}; // Ensure CPT entry exists
      for (const state of node.states) {
        node.cpt[key][state] = (cptCounters[key][state] || BN_LAPLACE_SMOOTHING) / totalForKeyWithSmoothing;
      }
    }

    function computeBNPredictionError(runData) {
      const preds = runData.statistics.bnPredictionsAtRunStart;
      if (!preds) return null;
      const stats = runData.statistics;
      const params = runData.parameters;
      const duration = runData.durationFrames > 0 ? runData.durationFrames : 1;

      const actualExtPrey = (stats.deathFrames.prey !== null && params.initialPrey > 0) ? 1 : 0;
      const actualExtPred = (stats.deathFrames.predator !== null && params.initialPredators > 0) ? 1 : 0;
      const actualGrowthPlant = (stats.totalPlantBirths / duration) > (stats.totalPlantsConsumed / duration) ? 1 : 0;
      const actualGrowthPrey = (stats.totalPreyBirths / duration) > ((stats.totalPreyDeathsByPredation + stats.totalPreyDeathsByStarvation) / duration) ? 1 : 0;
      const actualGrowthPred = (stats.totalPredatorBirths / duration) > ((stats.totalPredatorDeathsByStarvation + stats.totalPredatorDeathsByMobbing) / duration) ? 1 : 0;

      const errors = [];
      if (preds.extinction && preds.extinction.prey !== undefined && params.initialPrey > 0) {
        errors.push(Math.pow(preds.extinction.prey - actualExtPrey, 2));
      }
      if (preds.extinction && preds.extinction.predator !== undefined && params.initialPredators > 0) {
        errors.push(Math.pow(preds.extinction.predator - actualExtPred, 2));
      }
      if (preds.growth && preds.growth.plant !== undefined && params.initialPlants > 0) {
        errors.push(Math.pow(preds.growth.plant - actualGrowthPlant, 2));
      }
      if (preds.growth && preds.growth.prey !== undefined && params.initialPrey > 0) {
        errors.push(Math.pow(preds.growth.prey - actualGrowthPrey, 2));
      }
      if (preds.growth && preds.growth.predator !== undefined && params.initialPredators > 0) {
        errors.push(Math.pow(preds.growth.predator - actualGrowthPred, 2));
      }
      if (errors.length === 0) return null;
      return errors.reduce((a, b) => a + b, 0) / errors.length;
    }

    // Predicts extinction probabilities for given candidate parameters
    function predictExtinctionProbabilities(candidateBaseParams) {
      const defaultPred = { plant: 0.5, prey: 0.5, predator: 0.5, error: "BN not ready or error" };
      if (!isBNReady()) return defaultPred;

      const candidateFullParams = getFullParamsWithDerived(candidateBaseParams);
      const preds = { error: null };

      const getProb = (nodeName) => {
        const node = simBayesianNetwork.getNode(nodeName);
        if (!node) return 0.5; // Fallback
        const parentNames = node.parents.map(p => p.name);
        const parentConfigs = allBnParamAndDerivedNodeConfigs.filter(pConf => parentNames.includes(pConf.name));

        const relevantParamsForCPTKey = {};
        parentConfigs.forEach(pConf => { relevantParamsForCPTKey[pConf.configKey] = candidateFullParams[pConf.configKey]; });

        const cptKey = getParamKeyForCPT(relevantParamsForCPTKey, parentConfigs);
        return (node.cpt[cptKey] && node.cpt[cptKey]['true'] !== undefined) ? node.cpt[cptKey]['true'] : 0.5; // Prob of 'true'
      };

      preds.plant = 1 - getProb(BN_NODE_NAMES.FAVORABLE_GROWTH_PLANT);
      preds.prey = getProb(BN_NODE_NAMES.PREY_EXTINCTION);
      preds.predator = getProb(BN_NODE_NAMES.PREDATOR_EXTINCTION);
      return preds;
    }

    // Predicts favorable growth probabilities
    function predictFavorableGrowth(candidateBaseParams) {
      const defaultPred = { plant: 0.5, prey: 0.5, predator: 0.5, error: "BN not ready or error" };
      if (!isBNReady()) return defaultPred;

      const candidateFullParams = getFullParamsWithDerived(candidateBaseParams);
      const preds = { error: null };

      const getProb = (nodeName) => {
        const node = simBayesianNetwork.getNode(nodeName);
        if (!node) return 0.5;
        const parentNames = node.parents.map(p => p.name);
        const parentConfigs = allBnParamAndDerivedNodeConfigs.filter(pConf => parentNames.includes(pConf.name));

        const relevantParamsForCPTKey = {};
        parentConfigs.forEach(pConf => { relevantParamsForCPTKey[pConf.configKey] = candidateFullParams[pConf.configKey]; });

        const cptKey = getParamKeyForCPT(relevantParamsForCPTKey, parentConfigs);
        return (node.cpt[cptKey] && node.cpt[cptKey]['true'] !== undefined) ? node.cpt[cptKey]['true'] : 0.5;
      };

      preds.plant = getProb(BN_NODE_NAMES.FAVORABLE_GROWTH_PLANT);
      preds.prey = getProb(BN_NODE_NAMES.FAVORABLE_GROWTH_PREY);
      preds.predator = getProb(BN_NODE_NAMES.FAVORABLE_GROWTH_PREDATOR);
      return preds;
    }

    // Predicts starvation risk probabilities
    function predictStarvationRiskProbabilities(candidateBaseParams) {
      const defaultPred = { prey: 0.5, predator: 0.5, error: "BN not ready or error" };
      if (!isBNReady()) return defaultPred;

      const candidateFullParams = getFullParamsWithDerived(candidateBaseParams);
      const preds = { error: null };

      const getProb = (nodeName) => {
        const node = simBayesianNetwork.getNode(nodeName);
        if (!node) return 0.5;
        const parentNames = node.parents.map(p => p.name);
        const parentConfigs = allBnParamAndDerivedNodeConfigs.filter(pConf => parentNames.includes(pConf.name));

        const relevantParamsForCPTKey = {};
        parentConfigs.forEach(pConf => { relevantParamsForCPTKey[pConf.configKey] = candidateFullParams[pConf.configKey]; });

        const cptKey = getParamKeyForCPT(relevantParamsForCPTKey, parentConfigs);
        return (node.cpt[cptKey] && node.cpt[cptKey]['true'] !== undefined) ? node.cpt[cptKey]['true'] : 0.5;
      };

      preds.prey = getProb(BN_NODE_NAMES.PREY_STARVATION_RISK);
      preds.predator = getProb(BN_NODE_NAMES.PREDATOR_STARVATION_RISK);
      return preds;
    }


function updateCurrentBNPredictionsDisplay() {
      if (!simBayesianNetwork) return; 

      // For text display: use UI params for non-population, live counts for population
      const paramsForLiveTextDisplay = structuredClone(config); // Start with UI params
      // Override initial population parameters with current live counts
      paramsForLiveTextDisplay.initialPlants = plants.length;
      paramsForLiveTextDisplay.initialPrey = prey.length;
      paramsForLiveTextDisplay.initialPredators = predators.length;
      
      // Ensure these live counts are at least 0, BN's discretization handles min/max of its nodes.
      paramsForLiveTextDisplay.initialPlants = Math.max(0, paramsForLiveTextDisplay.initialPlants);
      paramsForLiveTextDisplay.initialPrey = Math.max(0, paramsForLiveTextDisplay.initialPrey);
      paramsForLiveTextDisplay.initialPredators = Math.max(0, paramsForLiveTextDisplay.initialPredators);


      const extPreds = predictExtinctionProbabilities(paramsForLiveTextDisplay);
      DOM_ELEMENTS.bnCurrentPreyExtinctionPrediction.textContent = extPreds.error ? `N/A (${extPreds.error.substring(0, 10)})` : extPreds.prey.toFixed(3);
      DOM_ELEMENTS.bnCurrentPredatorExtinctionPrediction.textContent = extPreds.error ? `N/A` : extPreds.predator.toFixed(3);

      const growthPreds = predictFavorableGrowth(paramsForLiveTextDisplay);
      DOM_ELEMENTS.bnCurrentPlantGrowthPrediction.textContent = growthPreds.error ? `N/A` : growthPreds.plant.toFixed(3);
      DOM_ELEMENTS.bnCurrentPreyGrowthPrediction.textContent = growthPreds.error ? `N/A` : growthPreds.prey.toFixed(3);
      DOM_ELEMENTS.bnCurrentPredatorGrowthPrediction.textContent = growthPreds.error ? `N/A` : growthPreds.predator.toFixed(3);

      const starvPreds = predictStarvationRiskProbabilities(paramsForLiveTextDisplay);
      DOM_ELEMENTS.bnCurrentPreyStarvationRiskPrediction.textContent = starvPreds.error ? `N/A` : starvPreds.prey.toFixed(3);
      DOM_ELEMENTS.bnCurrentPredStarvationRiskPrediction.textContent = starvPreds.error ? `N/A` : starvPreds.predator.toFixed(3);
    }


    // --- Simulation Configuration ---
    const config = {
      hue: 200, headerText: "Ecosystem Simulator", subheaderText: "Watch evolution unfold.",
      maxEntities: 5000, simulationSpeedMultiplier: 1.0,
      // Plant
      initialPlants: 100, plantReproduceRate: 0.002, plantMaxDensityRadius: 5, plantMaxNearby: 10,
      plantHealth: 1, planktonMode: true, planktonDriftSpeed: 0.1,
      plantSpawnSearchDist: 40, plantSpawnMaxAttempts: 10, plantSpawnSeparationMargin: 10,
      // Prey
      initialPrey: 40, preyRadius: 5, preyMaxSpeed: 2.0, preyAgility: 0.25,
      preyInertiaEffectStrength: 0.02, preyTurnSpeedPenaltyFactor: 0.05,
      preySharpTurnThresholdAngle: Math.PI / 12, // Approx 15 degrees
      preyHealth: 200, preyMaxHealth: 400,
      preyHealthGainFromPlant: 100, preyHealthToReproduce: 300, preyReproductionCost: 150,
      preyHungerRate: 0.5, preyEatDurationPlant: 60, // frames
      preyVisionRadius: 100, preyReproductionCooldown: 300, // frames
      // Predator
      initialPredators: 10, predatorRadius: 8, predatorMaxSpeed: 3.0, predatorAgility: 0.15,
      predatorInertiaEffectStrength: 0.08, predatorTurnSpeedPenaltyFactor: 0.20,
      predatorSharpTurnThresholdAngle: Math.PI / 18, // Approx 10 degrees
      predatorHealth: 300, predatorMaxHealth: 600,
      predatorHealthGainFromPrey: 200, predatorHealthToReproduce: 450, predatorReproductionCost: 220,
      predatorHungerRate: 0.8, predatorEatDurationPrey: 90, // frames
      predatorVisionRadius: 150, predatorReproductionCooldown: 480, // frames
      // Interaction & Visuals
      preyKillPredatorsMode: false, preyMinGroupToAttack: 3, preyGroupKillDuration: 180, // frames
      showTargetLines: true,
      birthAnimationDuration: 45, // frames
      deathAnimationDuration: 60, // frames
    };
    config.preyVisionRadiusSq = config.preyVisionRadius * config.preyVisionRadius;
    config.predatorVisionRadiusSq = config.predatorVisionRadius * config.predatorVisionRadius;

    let allSliderControls = []; // To store info about sliders for easier updates
    // Parameters tunable by the autopilot
    const tunableParams = [
      // Initial Populations
      { id: 'initialPlants', configKey: 'initialPlants', type: 'int', p_factor: 0.15, min: 10, max: 500, step: 10 },
      { id: 'initialPrey', configKey: 'initialPrey', type: 'int', p_factor: 0.15, min: 5, max: 200, step: 5 },
      { id: 'initialPredators', configKey: 'initialPredators', type: 'int', p_factor: 0.15, min: 1, max: 100, step: 1 },
      // Plant Settings
      { id: 'plantReproduceRate', configKey: 'plantReproduceRate', type: 'float', p_factor: 0.2, min: 0.0001, max: 0.01, step: 0.0001 }, // Max reduced for stability
      // Reproduction
      { id: 'preyReproductionCooldown', configKey: 'preyReproductionCooldown', type: 'int', p_factor: 0.1, min: 60, max: 1200, step: 10 },
      { id: 'predatorReproductionCooldown', configKey: 'predatorReproductionCooldown', type: 'int', p_factor: 0.1, min: 60, max: 1800, step: 10 },
      // Health (Max and Repro thresholds)
      { id: 'preyMaxHealth', configKey: 'preyMaxHealth', type: 'int', p_factor: 0.05, min: 200, max: 600, step: 20 },
      { id: 'preyHealthToReproduce', configKey: 'preyHealthToReproduce', type: 'int', p_factor: 0.1, min: 150, max: 580, step: 10 }, // Ensure min < maxHealth slider min
      { id: 'predatorMaxHealth', configKey: 'predatorMaxHealth', type: 'int', p_factor: 0.05, min: 300, max: 900, step: 20 },
      { id: 'predatorHealthToReproduce', configKey: 'predatorHealthToReproduce', type: 'int', p_factor: 0.1, min: 250, max: 880, step: 10 },
      // Movement (Prey)
      { id: 'preyMaxSpeed', configKey: 'preyMaxSpeed', type: 'float', p_factor: 0.1, min: 0.5, max: 5.0, step: 0.1 },
      { id: 'preyAgility', configKey: 'preyAgility', type: 'float', p_factor: 0.1, min: 0.05, max: 0.8, step: 0.01 },
      { id: 'preyInertiaEffectStrength', configKey: 'preyInertiaEffectStrength', type: 'float', p_factor: 0.15, min: 0.0, max: 0.2, step: 0.005 },
      { id: 'preyTurnSpeedPenaltyFactor', configKey: 'preyTurnSpeedPenaltyFactor', type: 'float', p_factor: 0.15, min: 0.0, max: 0.3, step: 0.01 },
      // Movement (Predator)
      { id: 'predatorMaxSpeed', configKey: 'predatorMaxSpeed', type: 'float', p_factor: 0.1, min: 0.8, max: 6.0, step: 0.1 },
      { id: 'predatorAgility', configKey: 'predatorAgility', type: 'float', p_factor: 0.1, min: 0.03, max: 0.6, step: 0.01 },
      { id: 'predatorInertiaEffectStrength', configKey: 'predatorInertiaEffectStrength', type: 'float', p_factor: 0.15, min: 0.0, max: 0.3, step: 0.005 },
      { id: 'predatorTurnSpeedPenaltyFactor', configKey: 'predatorTurnSpeedPenaltyFactor', type: 'float', p_factor: 0.15, min: 0.0, max: 0.5, step: 0.01 },
      // Hunger Rates
      { id: 'preyHungerRate', configKey: 'preyHungerRate', type: 'float', p_factor: 0.1, min: 0.1, max: 1.5, step: 0.05 },
      { id: 'predatorHungerRate', configKey: 'predatorHungerRate', type: 'float', p_factor: 0.1, min: 0.2, max: 2.0, step: 0.05 },
    ];

    // --- Utility Functions ---
    function getComputedCssVar(varName) { return getComputedStyle(document.documentElement).getPropertyValue(varName).trim(); }
    function getUrlParams() { const params = new URLSearchParams(window.location.search); config.hue = parseInt(params.get('hue')) || config.hue; config.headerText = params.get('header') || config.headerText; config.subheaderText = params.get('subheader') || config.subheaderText; document.documentElement.style.setProperty(CSS_VARS.BASE_HUE, config.hue); DOM_ELEMENTS.pageHeader.textContent = config.headerText; DOM_ELEMENTS.pageSubheader.textContent = config.subheaderText; }
    function random(min, max) { return Math.random() * (max - min) + min; }
    function randomInt(min, max) { return Math.floor(random(min, max + 1)); }
    function distance(x1, y1, x2, y2) { const dx = x1 - x2; const dy = y1 - y2; return Math.sqrt(dx * dx + dy * dy); }
    function distanceSq(x1, y1, x2, y2) { const dx = x1 - x2; const dy = y1 - y2; return dx * dx + dy * dy; }
    function normalizeAngle(angle) { while (angle > Math.PI) angle -= 2 * Math.PI; while (angle < -Math.PI) angle += 2 * Math.PI; return angle; }
    function clamp(val, min, max) { return Math.min(Math.max(val, min), max); }
    function weightedRandomSelect(options) { if (!options || options.length === 0) return null; const totalWeight = options.reduce((sum, option) => sum + Math.max(0, option.weight), 0); if (totalWeight <= 0) { return options.length > 0 ? options[randomInt(0, options.length - 1)].item : null; } let randomVal = Math.random() * totalWeight; for (const option of options) { const currentWeight = Math.max(0, option.weight); if (randomVal < currentWeight) return option.item; randomVal -= currentWeight; } return options.length > 0 ? options[options.length - 1].item : null; }

    function modifyHslColor(hslString, satMultiplier, lumMultiplier, alpha = null) {
      if (!hslString || typeof hslString !== 'string') return 'hsl(0,0%,0%)'; // Default fallback

      let match = hslString.match(/hsla?\(([\d.]+),\s*([\d.]+)%,\s*([\d.]+)%(?:,\s*([\d.]+))?\)/i);
      if (!match) {
        // console.warn("Could not parse HSL string:", hslString); // Keep commented unless debugging
        return hslString; // Return original if parsing fails
      }

      let [, h_str, s_str, l_str, a_str] = match;
      let h = parseFloat(h_str);
      let s = parseFloat(s_str);
      let l = parseFloat(l_str);
      let currentAlpha = a_str !== undefined ? parseFloat(a_str) : 1.0;

      s = Math.max(0, Math.min(100, s * satMultiplier));
      l = Math.max(0, Math.min(100, l * lumMultiplier));

      const finalAlpha = alpha !== null ? alpha : currentAlpha;

      if (finalAlpha < 1.0 && finalAlpha >= 0) { // Ensure alpha is valid
        return `hsla(${h}, ${s}%, ${l}%, ${finalAlpha.toFixed(3)})`;
      }
      return `hsl(${h}, ${s}%, ${l}%)`;
    }

    function easeOutQuad(t) {
      return t * (2 - t);
    }

    function drawRipple(x, y, progress, baseColor) {
      const rippleRadius = 8 + progress * 20;
      ctx.save();
      ctx.globalAlpha = (1 - progress) * 0.5;
      ctx.beginPath();
      ctx.arc(x, y, rippleRadius, 0, Math.PI * 2);
      ctx.strokeStyle = modifyHslColor(baseColor, 1.0, 1.2, ctx.globalAlpha);
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }


    // --- Vector & Entity Classes ---
    class Vector { constructor(x = 0, y = 0) { this.x = x; this.y = y; } add(v) { this.x += v.x; this.y += v.y; return this; } sub(v) { this.x -= v.x; this.y -= v.y; return this; } mult(s) { this.x *= s; this.y *= s; return this; } div(s) { if (s !== 0) { this.x /= s; this.y /= s; } return this; } mag() { return Math.sqrt(this.x * this.x + this.y * this.y); } magSq() { return this.x * this.x + this.y * this.y; } normalize() { const m = this.mag(); if (m > 0) this.div(m); return this; } limit(max) { if (this.magSq() > max * max) { this.normalize().mult(max); } return this; } static random2D() { return new Vector(random(-1, 1), random(-1, 1)).normalize(); } angle() { return Math.atan2(this.y, this.x); } clone() { return new Vector(this.x, this.y); } angleBetween(vOther) { if (this.magSq() === 0 || vOther.magSq() === 0) return 0; const dot = this.x * vOther.x + this.y * vOther.y; const cosTheta = dot / (this.mag() * vOther.mag()); return Math.acos(Math.max(-1, Math.min(1, cosTheta))); } }

    class Entity {
      constructor(x, y, radius) {
        this.pos = new Vector(x, y);
        this.vel = new Vector(random(-0.5, 0.5), random(-0.5, 0.5));
        this.acc = new Vector(0, 0);
        this.radius = radius;
        this.health = 100;
        this.isEating = false;
        this.eatTimer = 0;
        this.target = null;
        this.id = Math.random().toString(36).substr(2, 9) + Date.now();
        this.causeOfDeath = null;

        this.maxSpeed = 1;
        this.agility = 0.1;
        this.inertiaEffectStrength = 0;
        this.turnSpeedPenaltyFactor = 0;
        this.sharpTurnThresholdAngle = Math.PI / 4;

        this.animationState = 'alive'; // 'birthing', 'alive', 'dying', 'dead'
        this.animationProgress = 0; // 0-1 for current animation
        this.birthAnimTimer = 0; // Legacy, use animationState/Progress
        this.deathAnimTimer = 0; // Legacy, use animationState/Progress
        this.isEffectivelyDead = false; // Kept for some compatibility, prefer animationState
      }

      applyForce(force) { this.acc.add(force); }

      update() {
        switch (this.animationState) {
          case 'birthing':
            const birthDuration = (this.constructor.name === 'Plant' ? config.birthAnimationDuration / 1.5 : config.birthAnimationDuration); // Plants birth a bit faster
            this.birthAnimTimer = Math.max(0, this.birthAnimTimer - 1);
            this.animationProgress = 1 - (this.birthAnimTimer / birthDuration);
            if (this.birthAnimTimer <= 0) {
              this.animationState = 'alive';
              this.animationProgress = 0;
            }
            break;
          case 'dying':
            this.deathAnimTimer = Math.max(0, this.deathAnimTimer - 1);
            this.animationProgress = 1 - (this.deathAnimTimer / config.deathAnimationDuration);
            this.vel.mult(0.95); // Dampen velocity
            if (this.deathAnimTimer <= 0) {
              this.animationState = 'dead';
            }
            break;
          case 'alive':
            this.animationProgress = 0;
            break;
          case 'dead':
            return false; // Indicates entity should be removed
        }

        if (this.animationState !== 'dead') {
          const oldVel = this.vel.clone();
          this.vel.add(this.acc);
          this.acc.mult(0);

          const currentSpeed = this.vel.mag();
          if (this.animationState !== 'dying' && oldVel.magSq() > 0.0001 && currentSpeed > 0.01) {
            const angleTurned = oldVel.angleBetween(this.vel);
            if (Math.abs(angleTurned) > this.sharpTurnThresholdAngle) {
              const penaltySeverity = Math.min(1, Math.abs(angleTurned) / (Math.PI / 2));
              const speedReduction = currentSpeed * this.turnSpeedPenaltyFactor * penaltySeverity;
              const newSpeed = Math.max(0, currentSpeed - speedReduction);
              if (currentSpeed > 0.001) this.vel.normalize().mult(newSpeed);
              else this.vel.mult(0);
            }
          }
          this.vel.limit(this.maxSpeed);
          this.pos.add(this.vel);
          this.keepInBounds();
        }
        return true; // Still in simulation
      }

      keepInBounds() {
        const bounceDamping = -0.5;
        if (this.animationState === 'dying' || this.animationState === 'dead') return; // Don't bounce if dying/dead

        if (this.pos.x < this.radius) { this.pos.x = this.radius; this.vel.x *= bounceDamping; }
        if (this.pos.x > canvas.width - this.radius) { this.pos.x = canvas.width - this.radius; this.vel.x *= bounceDamping; }
        if (this.pos.y < this.radius) { this.pos.y = this.radius; this.vel.y *= bounceDamping; }
        if (this.pos.y > canvas.height - this.radius) { this.pos.y = canvas.height - this.radius; this.vel.y *= bounceDamping; }
      }
      draw() { /* Implemented by subclasses */ }
    }

    function findNonOverlappingSpot(parentPos, searchDist, maxAttempts, newPlantRadius, separationMargin) {
      for (let i = 0; i < maxAttempts; i++) {
        const angle = random(0, Math.PI * 2);
        const dist = random(newPlantRadius + separationMargin, searchDist * (0.25 + (i / maxAttempts) * 0.75));
        let newX = parentPos.x + Math.cos(angle) * dist;
        let newY = parentPos.y + Math.sin(angle) * dist;

        newX = Math.max(newPlantRadius, Math.min(canvas.width - newPlantRadius, newX));
        newY = Math.max(newPlantRadius, Math.min(canvas.height - newPlantRadius, newY));

        let overlaps = false;
        for (const p of plants) {
          if (distanceSq(newX, newY, p.pos.x, p.pos.y) < (newPlantRadius + p.radius + separationMargin) ** 2) {
            overlaps = true;
            break;
          }
        }
        if (!overlaps) {
          return { x: newX, y: newY };
        }
      }
      return null;
    }

    class Plant extends Entity {
      constructor(x, y) {
        super(x, y, 3);
        this.health = config.plantHealth;
        this.baseColor = getComputedCssVar(CSS_VARS.PLANT_COLOR);
        this.color = this.baseColor; // May be modified by animations
        this.isPlankton = config.planktonMode;
        if (this.isPlankton) this.vel = Vector.random2D().mult(config.planktonDriftSpeed);
        else this.vel = new Vector(0, 0);

        this.animationState = 'birthing';
        this.birthAnimTimer = config.birthAnimationDuration / 1.5; // Plants birth faster
        this.animationProgress = 0;
      }

      update() {
        if (!super.update()) return false; // Base entity update handles animation state, returns false if 'dead'

        if (this.health <= 0 && this.animationState !== 'dying' && this.animationState !== 'dead') {
          this.animationState = 'dying';
          this.deathAnimTimer = config.deathAnimationDuration; // Standard death duration
          this.isEffectivelyDead = true; // For compatibility if any logic still checks this
        }
        if (this.animationState === 'dying' || this.animationState === 'dead') {
          return this.animationState !== 'dead';
        }


        if (this.isPlankton !== config.planktonMode) {
          this.isPlankton = config.planktonMode;
          if (this.isPlankton) this.vel = Vector.random2D().mult(config.planktonDriftSpeed);
          else this.vel = new Vector(0, 0);
        }

        if (this.isPlankton) {
          // Plankton movement handled by base Entity.update if vel is set
          // Wrap around screen edges
          if (this.pos.x < -this.radius) this.pos.x = canvas.width + this.radius;
          if (this.pos.x > canvas.width + this.radius) this.pos.x = -this.radius;
          if (this.pos.y < -this.radius) this.pos.y = canvas.height + this.radius;
          if (this.pos.y > canvas.height + this.radius) this.pos.y = -this.radius;
        }

        if (this.animationState === 'alive' && Math.random() < config.plantReproduceRate && plants.length < config.maxEntities * 0.6) {
          let nearbyPlantsInArea = 0;
          for (const otherPlant of plants) {
            if (otherPlant !== this && distanceSq(this.pos.x, this.pos.y, otherPlant.pos.x, otherPlant.pos.y) < config.plantMaxDensityRadius * config.plantMaxDensityRadius) {
              nearbyPlantsInArea++;
            }
          }

          if (nearbyPlantsInArea < config.plantMaxNearby) {
            const newPlantObj = new Plant(0, 0);
            const spot = findNonOverlappingSpot(this.pos, config.plantSpawnSearchDist, config.plantSpawnMaxAttempts, newPlantObj.radius, config.plantSpawnSeparationMargin);
            if (spot) {
              const newPlant = new Plant(spot.x, spot.y);
              plants.push(newPlant);
              totalPlantBirths++;
            }
          }
        }
        return true;
      }

      draw() {
        ctx.save();
        let scaleFactor = 1.0;
        let alphaFactor = 1.0;
        let finalColor = this.baseColor;

        if (this.animationState === 'birthing') {
          const birthProgress = this.animationProgress;
          const initialScale = 0.05, peakScale = 1.5, finalScale = 1.0;
          const rampUpDuration = 0.5;

          if (birthProgress < rampUpDuration) {
            const eased = easeOutQuad(birthProgress / rampUpDuration);
            scaleFactor = initialScale + (peakScale - initialScale) * eased;
            const flashProgress = birthProgress / rampUpDuration;
            const L_boost = 30 * (1 - flashProgress);
            const S_boost_factor = 1 + 0.3 * (1 - flashProgress);
            finalColor = modifyHslColor(this.baseColor, S_boost_factor, 1 + (L_boost / 100));
          } else {
            const eased = easeOutQuad((birthProgress - rampUpDuration) / (1 - rampUpDuration));
            scaleFactor = peakScale - (peakScale - finalScale) * eased;
            finalColor = this.baseColor;
          }
          alphaFactor = 0.2 + 0.8 * Math.min(1, birthProgress * 2.0);
          drawRipple(this.pos.x, this.pos.y, birthProgress, this.baseColor);
        } else if (this.animationState === 'alive') {
          const breath = 1 + 0.05 * Math.sin((currentRunFrameCounter + parseInt(this.id.slice(-5),36)) / 20);
          scaleFactor *= breath;
        } else if (this.animationState === 'dying') {
          const deathProgress = this.animationProgress;
          scaleFactor = Math.max(0, 1 - deathProgress);
          alphaFactor = Math.max(0, 1 - deathProgress);
          finalColor = modifyHslColor(this.baseColor, 1 - deathProgress * 0.7, 1 - deathProgress * 0.2, alphaFactor);
        }

        ctx.globalAlpha = alphaFactor;
        const currentRadius = this.radius * scaleFactor;

        if (currentRadius > 0.1 && alphaFactor > 0.01) {
          ctx.beginPath();
          ctx.arc(this.pos.x, this.pos.y, currentRadius, 0, Math.PI * 2);
          ctx.fillStyle = finalColor;
          ctx.fill();
        }
        ctx.restore();
      }
    }

    class Prey extends Entity {
      constructor(x, y) {
        super(x, y, config.preyRadius);
        this.health = config.preyHealth;
        this.maxSpeed = config.preyMaxSpeed;
        this.agility = config.preyAgility;
        this.inertiaEffectStrength = config.preyInertiaEffectStrength;
        this.turnSpeedPenaltyFactor = config.preyTurnSpeedPenaltyFactor;
        this.sharpTurnThresholdAngle = config.preySharpTurnThresholdAngle;
        this.baseColor = getComputedCssVar(CSS_VARS.PREY_COLOR);
        this.color = this.baseColor;
        this.isFleeing = false;
        this.reproductionCooldown = 0;
        this.isAttackingPredatorTarget = null;

        this.lastHealth = this.health;
        this.flinchTimer = 0;

        this.animationState = 'birthing';
        this.birthAnimTimer = config.birthAnimationDuration;
        this.animationProgress = 0;
      }

      getEffectiveAgility(baseMultiplier = 1.0) { return (this.agility * baseMultiplier) / (1 + this.inertiaEffectStrength * this.vel.mag()); }
      seek(targetPos) { const desired = new Vector(targetPos.x - this.pos.x, targetPos.y - this.pos.y); if (desired.magSq() === 0) return new Vector(0, 0); desired.normalize().mult(this.maxSpeed); const steer = new Vector(desired.x - this.vel.x, desired.y - this.vel.y); steer.limit(this.getEffectiveAgility()); return steer; }
      flee(targetPos) { const desired = new Vector(this.pos.x - targetPos.x, this.pos.y - targetPos.y); if (desired.magSq() === 0) return Vector.random2D().mult(this.getEffectiveAgility(1.5)); desired.normalize().mult(this.maxSpeed); const steer = new Vector(desired.x - this.vel.x, desired.y - this.vel.y); steer.limit(this.getEffectiveAgility(1.5)); return steer; }
      findFood() { let closestFood = null, closestDistSq = Infinity; const visionRadiusSq = config.preyVisionRadiusSq; for (const plant of plants) { if (plant.health <= 0 || plant.animationState === 'dying' || plant.animationState === 'dead') continue; const dSq = distanceSq(this.pos.x, this.pos.y, plant.pos.x, plant.pos.y); if (dSq < closestDistSq && dSq < visionRadiusSq) { closestDistSq = dSq; closestFood = plant; } } return closestFood; }
      findPredator() { let closestPredator = null, closestDistSq = Infinity; const visionRadiusSq = config.preyVisionRadiusSq * (0.75 * 0.75); for (const predator of predators) { if (predator.animationState === 'dying' || predator.animationState === 'dead') continue; const dSq = distanceSq(this.pos.x, this.pos.y, predator.pos.x, predator.pos.y); if (dSq < closestDistSq && dSq < visionRadiusSq) { closestDistSq = dSq; closestPredator = predator; } } return closestPredator; }

      update() {
        if (!super.update()) return false; // Base handles animation state

        this.maxSpeed = config.preyMaxSpeed; this.agility = config.preyAgility; this.inertiaEffectStrength = config.preyInertiaEffectStrength; this.turnSpeedPenaltyFactor = config.preyTurnSpeedPenaltyFactor; this.sharpTurnThresholdAngle = config.preySharpTurnThresholdAngle;

        if (this.health <= 0 && this.animationState !== 'dying' && this.animationState !== 'dead') {
          this.animationState = 'dying';
          this.deathAnimTimer = config.deathAnimationDuration;
          this.isEffectivelyDead = true;
          if (!this.causeOfDeath) this.causeOfDeath = 'starvation';
        }
        if (this.animationState === 'dying' || this.animationState === 'dead') {
          return this.animationState !== 'dead';
        }

        if (this.reproductionCooldown > 0) this.reproductionCooldown--;
        this.health -= config.preyHungerRate;
        this.health = Math.min(this.health, config.preyMaxHealth);
        if (this.health < this.lastHealth) this.flinchTimer = 5;
        this.lastHealth = this.health;
        if (this.flinchTimer > 0) this.flinchTimer--;

        let steeringForce = new Vector(0, 0);
        const nearbyPredator = this.findPredator();
        this.isFleeing = false;
        this.isAttackingPredatorTarget = null;
        this.color = this.baseColor;

        if (nearbyPredator) {
          if (config.preyKillPredatorsMode) {
            if (nearbyPredator.animationState !== 'dying' && nearbyPredator.animationState !== 'dead' &&
              (nearbyPredator.health < this.health * 0.75 ||
                (nearbyPredator.attackedByPreyTimer > config.preyGroupKillDuration / 3 && nearbyPredator.preyAttackers.size > 0) ||
                (this.health > config.preyMaxHealth * 0.8 && nearbyPredator.health < config.predatorMaxHealth * 0.8))) {
              this.target = nearbyPredator;
              this.isAttackingPredatorTarget = nearbyPredator;
              steeringForce = this.seek(nearbyPredator.pos);
              this.color = `hsl(calc(${getComputedCssVar(CSS_VARS.BASE_HUE)} + 30), 90%, 70%)`;
            } else {
              steeringForce = this.flee(nearbyPredator.pos);
              this.isFleeing = true; this.target = null;
            }
          } else {
            steeringForce = this.flee(nearbyPredator.pos);
            this.isFleeing = true; this.target = null;
          }
        }

        if (this.isFleeing || this.isAttackingPredatorTarget) {
          this.isEating = false; this.eatTimer = 0;
          if (this.isAttackingPredatorTarget && this.target && distanceSq(this.pos.x, this.pos.y, this.target.pos.x, this.target.pos.y) < (this.radius + this.target.radius + 5) ** 2) {
            this.vel.mult(0.85);
          }
        } else if (this.isEating && this.target) {
          if (this.target.health <= 0 || this.target.animationState === 'dying' || this.target.animationState === 'dead' || distanceSq(this.pos.x, this.pos.y, this.target.pos.x, this.target.pos.y) > (this.radius + this.target.radius + 5) ** 2) {
            this.isEating = false; this.eatTimer = 0; this.target = null;
          } else {
            this.eatTimer++;
            if (this.eatTimer >= config.preyEatDurationPlant) {
              this.health += config.preyHealthGainFromPlant;
              this.target.health = 0; // Plant is consumed
              if (this.target instanceof Plant) { // Ensure it's a Plant before changing state
                this.target.animationState = 'dying';
                this.target.deathAnimTimer = config.deathAnimationDuration; // Start its death animation
              }
              totalPlantsConsumed++;
              this.isEating = false; this.eatTimer = 0; this.target = null;
            }
          }
        } else if (this.health < config.preyMaxHealth * 0.9) {
          const food = this.findFood();
          if (food) {
            this.target = food;
            if (distanceSq(this.pos.x, this.pos.y, food.pos.x, food.pos.y) < (this.radius + food.radius) ** 2) {
              this.isEating = true; this.eatTimer = 0; this.vel.mult(0.1);
            } else {
              steeringForce = this.seek(food.pos);
            }
          } else {
            steeringForce = Vector.random2D().mult(this.getEffectiveAgility(0.5)); this.target = null;
          }
        } else if (this.health >= config.preyHealthToReproduce && this.reproductionCooldown <= 0) {
          steeringForce = Vector.random2D().mult(this.getEffectiveAgility(0.2)); this.target = null;
        } else {
          steeringForce = Vector.random2D().mult(this.getEffectiveAgility(0.3)); this.target = null;
        }

        this.applyForce(steeringForce);
        // super.update() already called at the start

        if (this.animationState === 'alive' && this.health >= config.preyHealthToReproduce && this.reproductionCooldown <= 0) {
          this.health -= config.preyReproductionCost;
          const offspring = new Prey(this.pos.x + random(-5, 5), this.pos.y + random(-5, 5));
          offspring.health = config.preyHealth / 2;
          prey.push(offspring);
          totalPreyBirths++;
          this.reproductionCooldown = config.preyReproductionCooldown;
        }
        return true;
      }

      draw() {
        ctx.save();
        let scaleFactor = 1.0, alphaFactor = 1.0;
        let dynamicStrokeColor = this.color;
        let birthProgress = 0, deathProgress = 0;
        const orientation = this.vel.magSq() > 0.001 ? this.vel.angle() : 0;

        if (this.animationState === 'dying') {
          deathProgress = this.animationProgress;
          scaleFactor = Math.pow(1 - deathProgress, 1.5);
          alphaFactor = (1 - deathProgress);
          const desatProgress = deathProgress * 0.8;
          const darkenProgress = deathProgress * 0.3;
          dynamicStrokeColor = modifyHslColor(this.baseColor, 1 - desatProgress, 1 - darkenProgress, alphaFactor);
        } else if (this.animationState === 'birthing') {
          birthProgress = this.animationProgress;
          const initialScale = 0.1, peakScale = 1.4, finalScale = 1.0;
          const rampUpDuration = 0.5;
          if (birthProgress < rampUpDuration) {
            const eased = easeOutQuad(birthProgress / rampUpDuration);
            scaleFactor = initialScale + (peakScale - initialScale) * eased;
            const flashProgress = birthProgress / rampUpDuration;
            dynamicStrokeColor = modifyHslColor(this.baseColor, 1 + 0.4 * (1 - flashProgress), 1 + 0.2 * (1 - flashProgress));
          } else {
            const eased = easeOutQuad((birthProgress - rampUpDuration) / (1 - rampUpDuration));
            scaleFactor = peakScale - (peakScale - finalScale) * eased;
            dynamicStrokeColor = this.color;
          }
          alphaFactor = 0.2 + 0.8 * Math.min(1, birthProgress * 2.0);
          drawRipple(this.pos.x, this.pos.y, birthProgress, this.baseColor);
        } else if (this.animationState === 'alive') {
          const breath = 1 + 0.05 * Math.sin((currentRunFrameCounter + parseInt(this.id.slice(-5),36)) / 20);
          scaleFactor *= breath;
          if (this.flinchTimer > 0) scaleFactor *= 1 + 0.1 * (this.flinchTimer / 5);
          const healthRatio = clamp(this.health / config.preyMaxHealth, 0, 1);
          dynamicStrokeColor = modifyHslColor(dynamicStrokeColor, 1 - 0.3 * (1 - healthRatio), 1 - 0.2 * (1 - healthRatio));
        }

        ctx.globalAlpha = alphaFactor;
        const currentRadius = this.radius * scaleFactor;

        if (currentRadius > 0.1 && alphaFactor > 0.01) {
          ctx.save();
          ctx.translate(this.pos.x, this.pos.y);
          ctx.rotate(orientation);
          ctx.scale(1.2, 1);
          ctx.beginPath();
          ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
          ctx.strokeStyle = dynamicStrokeColor;
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.restore();

          if (this.animationState !== 'dying' && alphaFactor > 0.1 && scaleFactor > 0.25) {
            const healthPercentage = Math.max(0, this.health / config.preyMaxHealth);
            const healthBarWidth = currentRadius * 2;
            const healthBarHeight = 3;
            const healthBarY = this.pos.y - currentRadius - 7;

            ctx.fillStyle = 'hsla(0, 0%, 20%, 0.6)'; // Background
            ctx.fillRect(this.pos.x - healthBarWidth / 2, healthBarY, healthBarWidth, healthBarHeight);
            ctx.fillStyle = healthPercentage > 0.6 ? 'hsl(120, 70%, 50%)' : (healthPercentage > 0.3 ? 'hsl(60, 70%, 50%)' : 'hsl(0, 70%, 50%)');
            ctx.fillRect(this.pos.x - healthBarWidth / 2, healthBarY, healthBarWidth * healthPercentage, healthBarHeight);
          }
          if (this.isEating && !this.isAttackingPredatorTarget && this.animationState === 'alive') {
            const eatPulse = Math.sin((currentRunFrameCounter + parseInt(this.id.slice(-5), 36) % 30) * Math.PI / 15) * 0.15 + 0.15;
            ctx.fillStyle = modifyHslColor(getComputedCssVar(CSS_VARS.PLANT_COLOR), 1.2, 1.1, eatPulse);
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, currentRadius + 2 + eatPulse * 3, 0, Math.PI * 2);
            ctx.fill();
          }
          // Eye
          if ((this.animationState === 'alive' || (this.animationState === 'birthing' && birthProgress > 0.7)) && scaleFactor > 0.5) {
            const eyeRadius = Math.max(1, currentRadius * 0.15);
            const eyeOffsetMagnitude = currentRadius * 0.4;
            let eyePosX = this.pos.x, eyePosY = this.pos.y;
            if (this.vel.magSq() > 0.01) { const dir = this.vel.clone().normalize(); eyePosX += dir.x * eyeOffsetMagnitude; eyePosY += dir.y * eyeOffsetMagnitude; }
            else { eyePosX += eyeOffsetMagnitude * Math.cos(this.vel.angle() || 0); eyePosY += eyeOffsetMagnitude * Math.sin(this.vel.angle() || 0); } // Use current vel angle or default (0 rad)
            ctx.beginPath(); ctx.arc(eyePosX, eyePosY, eyeRadius, 0, Math.PI * 2);
            ctx.fillStyle = this.isFleeing ? `hsla(calc(${getComputedCssVar(CSS_VARS.BASE_HUE)} + 180), 80%, 60%, ${alphaFactor})` : `hsla(0, 0%, 10%, ${alphaFactor * 0.9})`;
            ctx.fill();
          }
        }

        if (this.animationState === 'dying' && deathProgress > 0.05 && deathProgress < 0.95) {
          drawRipple(this.pos.x, this.pos.y, deathProgress, this.baseColor);
          const numFragments = 3 + Math.floor(Math.random() * 2);
          const fragmentBaseMaxRadius = this.radius * 0.3;
          for (let i = 0; i < numFragments; i++) {
            const randomSeedForFrag = parseInt(this.id.substring(0, 5), 36) + i;
            const fragmentAngle = (randomSeedForFrag * 2.3999632297) % (Math.PI * 2);
            const outwardPushFactor = 0.3 + deathProgress * 1.8;
            const fragX = this.pos.x + Math.cos(fragmentAngle) * this.radius * 0.15 * outwardPushFactor;
            const fragY = this.pos.y + Math.sin(fragmentAngle) * this.radius * 0.15 * outwardPushFactor;
            const fragmentRadius = fragmentBaseMaxRadius * Math.max(0, (1 - deathProgress * 1.1)) * (0.4 + ((randomSeedForFrag * 13) % 100) / 100 * 0.6);
            const fragmentSpecificAlphaMod = (0.7 - deathProgress * 0.6) * (0.5 + ((randomSeedForFrag * 7) % 100) / 100 * 0.5) * (1 - deathProgress);
            if (fragmentRadius > 0.5 && fragmentSpecificAlphaMod * alphaFactor > 0.05) {
              ctx.beginPath(); ctx.arc(fragX, fragY, fragmentRadius, 0, Math.PI * 2);
              ctx.fillStyle = modifyHslColor(this.baseColor, 0.4, 1.2, fragmentSpecificAlphaMod * alphaFactor);
              ctx.fill();
            }
          }
        }
        ctx.restore();
      }
    }

    class Predator extends Entity {
      constructor(x, y) {
        super(x, y, config.predatorRadius);
        this.health = config.predatorHealth;
        this.maxSpeed = config.predatorMaxSpeed;
        this.agility = config.predatorAgility;
        this.inertiaEffectStrength = config.predatorInertiaEffectStrength;
        this.turnSpeedPenaltyFactor = config.predatorTurnSpeedPenaltyFactor;
        this.sharpTurnThresholdAngle = config.predatorSharpTurnThresholdAngle;
        this.baseColor = getComputedCssVar(CSS_VARS.PREDATOR_COLOR);
        this.mobbedColor = getComputedCssVar(CSS_VARS.PREDATOR_MOBBED_COLOR);
        this.color = this.baseColor;
        this.reproductionCooldown = 0;
        this.attackedByPreyTimer = 0;
        this.preyAttackers = new Set();

        this.lastHealth = this.health;
        this.flinchTimer = 0;

        this.animationState = 'birthing';
        this.birthAnimTimer = config.birthAnimationDuration;
        this.animationProgress = 0;
      }

      getEffectiveAgility(baseMultiplier = 1.0) { return (this.agility * baseMultiplier) / (1 + this.inertiaEffectStrength * this.vel.mag()); }
      seek(targetPos) { const desired = new Vector(targetPos.x - this.pos.x, targetPos.y - this.pos.y); if (desired.magSq() === 0) return new Vector(0, 0); desired.normalize().mult(this.maxSpeed); const steer = new Vector(desired.x - this.vel.x, desired.y - this.vel.y); steer.limit(this.getEffectiveAgility()); return steer; }
      flee(targetPos) { const desired = new Vector(this.pos.x - targetPos.x, this.pos.y - targetPos.y); if (desired.magSq() === 0) return Vector.random2D().mult(this.getEffectiveAgility(1.2)); desired.normalize().mult(this.maxSpeed); const steer = new Vector(desired.x - this.vel.x, desired.y - this.vel.y); steer.limit(this.getEffectiveAgility(1.2)); return steer; }
      findFood() { let closestFood = null, closestDistSq = Infinity; const visionRadiusSq = config.predatorVisionRadiusSq; for (const p of prey) { if (p.animationState === 'dying' || p.animationState === 'dead') continue; const dSq = distanceSq(this.pos.x, this.pos.y, p.pos.x, p.pos.y); if (dSq < closestDistSq && dSq < visionRadiusSq) { closestDistSq = dSq; closestFood = p; } } return closestFood; }

      update() {
        if (!super.update()) return false;

        this.maxSpeed = config.predatorMaxSpeed; this.agility = config.predatorAgility; this.inertiaEffectStrength = config.predatorInertiaEffectStrength; this.turnSpeedPenaltyFactor = config.predatorTurnSpeedPenaltyFactor; this.sharpTurnThresholdAngle = config.predatorSharpTurnThresholdAngle;

        if (this.health <= 0 && this.animationState !== 'dying' && this.animationState !== 'dead') {
          this.animationState = 'dying';
          this.deathAnimTimer = config.deathAnimationDuration;
          this.isEffectivelyDead = true;
          if (!this.causeOfDeath) this.causeOfDeath = 'starvation';
        }
        if (this.animationState === 'dying' || this.animationState === 'dead') {
          return this.animationState !== 'dead';
        }

        if (this.reproductionCooldown > 0) this.reproductionCooldown--;
        this.health -= config.predatorHungerRate;
        this.health = Math.min(this.health, config.predatorMaxHealth);
        if (this.health < this.lastHealth) this.flinchTimer = 5;
        this.lastHealth = this.health;
        if (this.flinchTimer > 0) this.flinchTimer--;

        let steeringForce = new Vector(0, 0);
        let isFleeingMob = false;
        this.color = this.baseColor;

        if (config.preyKillPredatorsMode) {
          let currentFrameAttackersSet = new Set();
          let attackingPreyGroup = [];
          let combinedPreyHealth = 0;
          for (const p of prey) {
            if (p.animationState !== 'dying' && p.animationState !== 'dead' && p.isAttackingPredatorTarget === this && distanceSq(this.pos.x, this.pos.y, p.pos.x, p.pos.y) < (this.radius + p.radius + 15) ** 2) {
              attackingPreyGroup.push(p);
              combinedPreyHealth += p.health;
              currentFrameAttackersSet.add(p.id);
            }
          }

          if (attackingPreyGroup.length >= config.preyMinGroupToAttack && combinedPreyHealth > this.health * 0.7) {
            this.attackedByPreyTimer++;
            this.preyAttackers = currentFrameAttackersSet;
            this.color = this.mobbedColor;
            if (this.attackedByPreyTimer >= config.preyGroupKillDuration) {
              this.causeOfDeath = 'mobbing'; this.health = 0; // This will trigger 'dying' state next frame
            }
            let fleeCenter = new Vector(0, 0);
            if (attackingPreyGroup.length > 0) { attackingPreyGroup.forEach(p_entity => fleeCenter.add(p_entity.pos)); fleeCenter.div(attackingPreyGroup.length); }
            else { fleeCenter = this.pos; }
            steeringForce = this.flee(fleeCenter);
            this.isEating = false; this.eatTimer = 0; this.target = null;
            isFleeingMob = true;
          } else {
            if (this.attackedByPreyTimer > 0) this.attackedByPreyTimer = Math.max(0, this.attackedByPreyTimer - 2);
            if (this.attackedByPreyTimer === 0) this.preyAttackers.clear();
          }
        } else {
          this.attackedByPreyTimer = 0; this.preyAttackers.clear();
        }

        if (!isFleeingMob) {
          if (this.isEating && this.target) {
            if (this.target.animationState === 'dying' || this.target.animationState === 'dead' || distanceSq(this.pos.x, this.pos.y, this.target.pos.x, this.target.pos.y) > (this.radius + this.target.radius + 5) ** 2) {
              this.isEating = false; this.eatTimer = 0; this.target = null;
            } else {
              this.eatTimer++;
              if (this.eatTimer >= config.predatorEatDurationPrey) {
                this.health += config.predatorHealthGainFromPrey;
                if (this.target) {
                  this.target.causeOfDeath = 'predation'; this.target.health = 0; // Prey killed
                  if (this.target instanceof Prey) { // Ensure it's Prey before changing state
                    this.target.animationState = 'dying';
                    this.target.deathAnimTimer = config.deathAnimationDuration; // Start its death animation
                  }
                }
                this.isEating = false; this.eatTimer = 0; this.target = null;
              }
            }
          } else if (this.health < config.predatorMaxHealth * 0.85) {
            const food = this.findFood();
            if (food) {
              this.target = food;
              if (distanceSq(this.pos.x, this.pos.y, food.pos.x, food.pos.y) < (this.radius + food.radius) ** 2) {
                this.isEating = true; this.eatTimer = 0; this.vel.mult(0.1);
              } else {
                steeringForce = this.seek(food.pos);
              }
            } else {
              steeringForce = Vector.random2D().mult(this.getEffectiveAgility(0.5)); this.target = null;
            }
          } else if (this.health >= config.predatorHealthToReproduce && this.reproductionCooldown <= 0) {
            steeringForce = Vector.random2D().mult(this.getEffectiveAgility(0.2)); this.target = null;
          } else {
            steeringForce = Vector.random2D().mult(this.getEffectiveAgility(0.3)); this.target = null;
          }
        }

        this.applyForce(steeringForce);
        // super.update() already called

        if (this.animationState === 'alive' && this.health >= config.predatorHealthToReproduce && this.reproductionCooldown <= 0) {
          this.health -= config.predatorReproductionCost;
          const offspring = new Predator(this.pos.x + random(-5, 5), this.pos.y + random(-5, 5));
          offspring.health = config.predatorHealth / 2;
          predators.push(offspring);
          totalPredatorBirths++;
          this.reproductionCooldown = config.predatorReproductionCooldown;
        }
        return true;
      }

      draw() {
        ctx.save();
        let scaleFactor = 1.0, alphaFactor = 1.0;
        let dynamicStrokeColor = this.color;
        let birthProgress = 0, deathProgress = 0;
        const orientation = this.vel.magSq() > 0.001 ? this.vel.angle() : 0;

        if (this.animationState === 'dying') {
          deathProgress = this.animationProgress;
          scaleFactor = Math.pow(1 - deathProgress, 1.5);
          alphaFactor = (1 - deathProgress);
          const desatProgress = deathProgress * 0.8;
          const darkenProgress = deathProgress * 0.3;
          dynamicStrokeColor = modifyHslColor(this.baseColor, 1 - desatProgress, 1 - darkenProgress, alphaFactor);
        } else if (this.animationState === 'birthing') {
          birthProgress = this.animationProgress;
          const initialScale = 0.1, peakScale = 1.4, finalScale = 1.0;
          const rampUpDuration = 0.5;
          if (birthProgress < rampUpDuration) {
            const eased = easeOutQuad(birthProgress / rampUpDuration);
            scaleFactor = initialScale + (peakScale - initialScale) * eased;
            const flashProgress = birthProgress / rampUpDuration;
            dynamicStrokeColor = modifyHslColor(this.baseColor, 1 + 0.4 * (1 - flashProgress), 1 + 0.2 * (1 - flashProgress));
          } else {
            const eased = easeOutQuad((birthProgress - rampUpDuration) / (1 - rampUpDuration));
            scaleFactor = peakScale - (peakScale - finalScale) * eased;
            dynamicStrokeColor = this.color;
          }
          alphaFactor = 0.2 + 0.8 * Math.min(1, birthProgress * 2.0);
          drawRipple(this.pos.x, this.pos.y, birthProgress, this.baseColor);
        } else if (this.animationState === 'alive') {
          const breath = 1 + 0.05 * Math.sin((currentRunFrameCounter + parseInt(this.id.slice(-5),36)) / 20);
          scaleFactor *= breath;
          if (this.flinchTimer > 0) scaleFactor *= 1 + 0.1 * (this.flinchTimer / 5);
          const healthRatio = clamp(this.health / config.predatorMaxHealth, 0, 1);
          dynamicStrokeColor = modifyHslColor(dynamicStrokeColor, 1 - 0.3 * (1 - healthRatio), 1 - 0.2 * (1 - healthRatio));
        }

        ctx.globalAlpha = alphaFactor;
        const currentRadius = this.radius * scaleFactor;

        if (currentRadius > 0.1 && alphaFactor > 0.01) {
          ctx.save();
          ctx.translate(this.pos.x, this.pos.y);
          ctx.rotate(orientation);
          ctx.scale(1.2, 1);
          ctx.beginPath();
          ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
          ctx.strokeStyle = dynamicStrokeColor;
          ctx.lineWidth = 3;
          ctx.stroke();
          ctx.restore();

          if (this.animationState !== 'dying' && alphaFactor > 0.1 && scaleFactor > 0.25) {
            const healthPercentage = Math.max(0, this.health / config.predatorMaxHealth);
            const healthBarWidth = currentRadius * 2;
            const healthBarHeight = 3;
            const healthBarY = this.pos.y - currentRadius - 7;

            ctx.fillStyle = 'hsla(0, 0%, 20%, 0.6)'; // Background
            ctx.fillRect(this.pos.x - healthBarWidth / 2, healthBarY, healthBarWidth, healthBarHeight);
            ctx.fillStyle = healthPercentage > 0.6 ? 'hsl(200, 70%, 60%)' : (healthPercentage > 0.3 ? 'hsl(30, 70%, 60%)' : 'hsl(0, 60%, 45%)');
            ctx.fillRect(this.pos.x - healthBarWidth / 2, healthBarY, healthBarWidth * healthPercentage, healthBarHeight);
          }
          if (this.isEating && this.animationState === 'alive') {
            const eatPulse = Math.sin((currentRunFrameCounter + parseInt(this.id.slice(-5), 36) % 30) * Math.PI / 15) * 0.15 + 0.15;
            ctx.fillStyle = modifyHslColor(getComputedCssVar(CSS_VARS.PREY_COLOR), 1.2, 1.1, eatPulse);
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, currentRadius + 3 + eatPulse * 3, 0, Math.PI * 2);
            ctx.fill();
          }
          // Eye
          if ((this.animationState === 'alive' || (this.animationState === 'birthing' && birthProgress > 0.7)) && scaleFactor > 0.5) {
            const eyeRadius = Math.max(1, currentRadius * 0.2); // Predator eye slightly larger proportion
            const eyeOffsetMagnitude = currentRadius * 0.45;
            let eyePosX = this.pos.x, eyePosY = this.pos.y;
            if (this.vel.magSq() > 0.01) { const dir = this.vel.clone().normalize(); eyePosX += dir.x * eyeOffsetMagnitude; eyePosY += dir.y * eyeOffsetMagnitude; }
            else { eyePosX += eyeOffsetMagnitude * Math.cos(this.vel.angle() || 0); eyePosY += eyeOffsetMagnitude * Math.sin(this.vel.angle() || 0); }
            ctx.beginPath(); ctx.arc(eyePosX, eyePosY, eyeRadius, 0, Math.PI * 2);
            ctx.fillStyle = (this.attackedByPreyTimer > 0 || this.isEating) ? modifyHslColor(this.color, 1.2, 1.1, alphaFactor) : `hsla(0, 0%, 10%, ${alphaFactor * 0.9})`; // Eye matches aggressive color or dark
            ctx.fill();
          }
        }

        if (this.animationState === 'dying' && deathProgress > 0.05 && deathProgress < 0.95) {
          drawRipple(this.pos.x, this.pos.y, deathProgress, this.baseColor);
          const numFragments = 3 + Math.floor(Math.random() * 2);
          const fragmentBaseMaxRadius = this.radius * 0.3;
          for (let i = 0; i < numFragments; i++) {
            const randomSeedForFrag = parseInt(this.id.substring(0, 5), 36) + i;
            const fragmentAngle = (randomSeedForFrag * 2.3999632297) % (Math.PI * 2);
            const outwardPushFactor = 0.3 + deathProgress * 1.8;
            const fragX = this.pos.x + Math.cos(fragmentAngle) * this.radius * 0.15 * outwardPushFactor;
            const fragY = this.pos.y + Math.sin(fragmentAngle) * this.radius * 0.15 * outwardPushFactor;
            const fragmentRadius = fragmentBaseMaxRadius * Math.max(0, (1 - deathProgress * 1.1)) * (0.4 + ((randomSeedForFrag * 13) % 100) / 100 * 0.6);
            const fragmentSpecificAlphaMod = (0.7 - deathProgress * 0.6) * (0.5 + ((randomSeedForFrag * 7) % 100) / 100 * 0.5) * (1 - deathProgress);
            if (fragmentRadius > 0.5 && fragmentSpecificAlphaMod * alphaFactor > 0.05) {
              ctx.beginPath(); ctx.arc(fragX, fragY, fragmentRadius, 0, Math.PI * 2);
              ctx.fillStyle = modifyHslColor(this.baseColor, 0.4, 1.2, fragmentSpecificAlphaMod * alphaFactor);
              ctx.fill();
            }
          }
        }
        ctx.restore();
      }
    }

    // --- Game Setup & Loop ---
    function getPrecision(step) { const stepStr = step.toString(); return stepStr.includes('.') ? stepStr.split('.')[1].length : 0; }
    function updateSliderAndDisplay(sliderId, value, precision, type) { const slider = DOM_ELEMENTS[sliderId]; const valueDisplay = DOM_ELEMENTS[sliderId + 'Value']; if (slider) slider.value = value; if (valueDisplay) { valueDisplay.textContent = type === 'float' ? parseFloat(value).toFixed(precision) : value; } }

    function setupControls() {
      // Checkboxes
      DOM_ELEMENTS.planktonMode.checked = config.planktonMode;
      DOM_ELEMENTS.planktonMode.addEventListener('change', (e) => { config.planktonMode = e.target.checked; updateCurrentBNPredictionsDisplay(); });
      DOM_ELEMENTS.preyKillPredatorsMode.checked = config.preyKillPredatorsMode;
      DOM_ELEMENTS.preyKillPredatorsMode.addEventListener('change', (e) => { config.preyKillPredatorsMode = e.target.checked; updateCurrentBNPredictionsDisplay(); });
      DOM_ELEMENTS.showTargetLines.checked = config.showTargetLines;
      DOM_ELEMENTS.showTargetLines.addEventListener('change', (e) => { config.showTargetLines = e.target.checked; });

      // Simulation Speed Slider
      const simSpeedSlider = DOM_ELEMENTS.simulationSpeed;
      const simSpeedValueDisplay = DOM_ELEMENTS.simulationSpeedValue;
      simSpeedSlider.value = config.simulationSpeedMultiplier;
      simSpeedValueDisplay.textContent = config.simulationSpeedMultiplier.toFixed(1);
      simSpeedSlider.addEventListener('input', (e) => {
        config.simulationSpeedMultiplier = parseFloat(e.target.value);
        simSpeedValueDisplay.textContent = config.simulationSpeedMultiplier.toFixed(1);
      });

      // Tunable Parameter Sliders
      allSliderControls = tunableParams.map(param => ({
        id: param.id || param.configKey, // Use param.id if defined, else configKey
        configKey: param.configKey,
        valueDisplayId: (param.id || param.configKey) + 'Value',
        type: param.type,
        precision: getPrecision(param.step)
      }));

      allSliderControls.forEach(map => {
        const slider = DOM_ELEMENTS[map.id];
        const valueDisplay = DOM_ELEMENTS[map.valueDisplayId];
        if (!slider || !valueDisplay) {
          // console.warn(`Control or display not found for ${map.id}`);
          return;
        }
        // Initialize slider and config from default or current config value
        if (config[map.configKey] !== undefined) {
          slider.value = config[map.configKey];
          valueDisplay.textContent = map.type === 'float' ? parseFloat(config[map.configKey]).toFixed(map.precision) : config[map.configKey];
        } else { // Fallback if configKey is missing in `config` object
          const defaultValue = parseFloat(slider.value);
          config[map.configKey] = map.type === 'int' ? parseInt(defaultValue) : defaultValue;
          valueDisplay.textContent = map.type === 'float' ? defaultValue.toFixed(map.precision) : defaultValue;
        }
        // Event listener for slider input
        slider.addEventListener('input', (e) => {
          const newValue = map.type === 'int' ? parseInt(e.target.value) : parseFloat(e.target.value);
          valueDisplay.textContent = map.type === 'float' ? newValue.toFixed(map.precision) : newValue;
          config[map.configKey] = newValue;
          // Update BN predictions if a BN-relevant param changes
          if (allBnParamAndDerivedNodeConfigs.some(pConf => pConf.configKey === map.configKey && pConf.isTunable)) {
            updateCurrentBNPredictionsDisplay();
          }
        });
      });

      // Buttons
      DOM_ELEMENTS.resetSimulation.addEventListener('click', () => {
        console.log(`User manually reset for run ${currentRunNumber + 1}.`);
        const currentConfigSnapshot = structuredClone(config);
        let bnExtPreds = null, bnGrowthPreds = null, bnStarvPreds = null;
        if (isBNReady()) { // Get predictions for the *next* run's parameters
          bnExtPreds = predictExtinctionProbabilities(currentConfigSnapshot);
          bnGrowthPreds = predictFavorableGrowth(currentConfigSnapshot);
          bnStarvPreds = predictStarvationRiskProbabilities(currentConfigSnapshot);
        }
        bnPredictionsForNextRun = { extinction: bnExtPreds, growth: bnGrowthPreds, starvationRisk: bnStarvPreds };
        updateCurrentBNPredictionsDisplay(); // Update display for current UI settings
        startNewRun(currentConfigSnapshot);
      });

      DOM_ELEMENTS.autoPilotRun.addEventListener('click', () => {
        const suggestedParams = suggestNextParameters(); // This already sets bnPredictionsForNextRun
        if (suggestedParams) {
          console.log(`Auto-pilot suggested parameters for run ${currentRunNumber + 1}. Starting...`);
          startNewRun(suggestedParams);
        } else {
          console.log("Auto-pilot could not suggest parameters. Resetting with current settings.");
          const currentConfigSnapshot = structuredClone(config);
          let bnExtPreds = null, bnGrowthPreds = null, bnStarvPreds = null;
          if (isBNReady()) {
            bnExtPreds = predictExtinctionProbabilities(currentConfigSnapshot);
            bnGrowthPreds = predictFavorableGrowth(currentConfigSnapshot);
            bnStarvPreds = predictStarvationRiskProbabilities(currentConfigSnapshot);
          }
          bnPredictionsForNextRun = { extinction: bnExtPreds, growth: bnGrowthPreds, starvationRisk: bnStarvPreds };
          startNewRun(currentConfigSnapshot);
        }
      });

      // Overlay Toggles
      // Ensure statsToggle also resizes the new graph
      DOM_ELEMENTS.statsToggle.addEventListener('click', () => {
        DOM_ELEMENTS.statsOverlay.classList.toggle('visible');
        if (DOM_ELEMENTS.statsOverlay.classList.contains('visible')) {
          populationGraphCanvas.width = populationGraphCanvas.clientWidth;
          populationGraphCanvas.height = populationGraphCanvas.clientHeight;
          cumulativeGraphCanvas.width = cumulativeGraphCanvas.clientWidth;
          cumulativeGraphCanvas.height = cumulativeGraphCanvas.clientHeight;
          if (bnPredictionGraphCanvas) { // Check if it exists
            bnPredictionGraphCanvas.width = bnPredictionGraphCanvas.clientWidth;
            bnPredictionGraphCanvas.height = bnPredictionGraphCanvas.clientHeight;
            drawBNPredictionGraph();
          }
          if (bnPredictionExtinctionGraphCanvas) {
            bnPredictionExtinctionGraphCanvas.width = bnPredictionExtinctionGraphCanvas.clientWidth;
            bnPredictionExtinctionGraphCanvas.height = bnPredictionExtinctionGraphCanvas.clientHeight;
            drawBNPredictionExtinctionGraph();
          }
          if (bnPredictionGrowthGraphCanvas) {
            bnPredictionGrowthGraphCanvas.width = bnPredictionGrowthGraphCanvas.clientWidth;
            bnPredictionGrowthGraphCanvas.height = bnPredictionGrowthGraphCanvas.clientHeight;
            drawBNPredictionGrowthGraph();
          }
          if (bnPredictionStarvationGraphCanvas) {
            bnPredictionStarvationGraphCanvas.width = bnPredictionStarvationGraphCanvas.clientWidth;
            bnPredictionStarvationGraphCanvas.height = bnPredictionStarvationGraphCanvas.clientHeight;
            drawBNPredictionStarvationGraph();
          }
          if (bnPredictionErrorGraphCanvas) {
            bnPredictionErrorGraphCanvas.width = bnPredictionErrorGraphCanvas.clientWidth;
            bnPredictionErrorGraphCanvas.height = bnPredictionErrorGraphCanvas.clientHeight;
            drawBNPredictionErrorGraph();
          }
          drawPopulationGraph();
          drawCumulativeGraph();
          updateRunStartBNPredictionsDisplay();
          updateCurrentBNPredictionsDisplay();
          updateBnAccuracyDisplay();
        }
      });
      DOM_ELEMENTS.controlsToggle.addEventListener('click', () => { DOM_ELEMENTS.controlsOverlay.classList.toggle('visible'); });

      // Initially hide overlays
      DOM_ELEMENTS.statsOverlay.classList.remove('visible');
      DOM_ELEMENTS.controlsOverlay.classList.remove('visible');

      // Past Runs View Toggle & Back Button
      DOM_ELEMENTS.pastRunsToggleMain.addEventListener('click', () => {
        simulationIsActive = false; // Pause simulation
        simulationViewContainer.style.display = 'none';
        pastRunsViewContainer.style.display = 'block';
        bnVisualizationContainer.style.display = simBayesianNetwork ? 'block' : 'none';
        if (simBayesianNetwork) {
          setTimeout(() => { // Ensure canvas is visible and sized
            drawBayesianNetworkVisualization();
            populateBNLegend();
          }, 0);
        }
        document.body.style.overflow = 'auto'; // Allow scrolling in past runs view
        // Hide overlays and their toggles when viewing past runs
        DOM_ELEMENTS.statsOverlay.classList.remove('visible');
        DOM_ELEMENTS.controlsOverlay.classList.remove('visible');
        DOM_ELEMENTS.statsToggle.style.display = 'none';
        DOM_ELEMENTS.controlsToggle.style.display = 'none';
        DOM_ELEMENTS.pastRunsToggleMain.style.display = 'none';
        populatePastRunsSummaryList();
        DOM_ELEMENTS.pastRunDetails.style.display = 'none'; // Hide details initially
      });
      DOM_ELEMENTS.backToSimulationButton.addEventListener('click', () => {
        pastRunsViewContainer.style.display = 'none';
        bnVisualizationContainer.style.display = 'none';
        simulationViewContainer.style.display = 'block';
        document.body.style.overflow = 'hidden'; // Disable body scroll for sim view
        simulationIsActive = true; // Resume simulation
        lastTimestamp = performance.now(); // Reset timestamp to avoid large deltaTime jump
        simulationTimeAccumulator = 0; // Reset accumulator
        if (!gameLoopRunning) { // If loop wasn't running, restart it
          animationFrameId = requestAnimationFrame(gameLoop);
        }
        DOM_ELEMENTS.currentRunInfo.classList.add('visible');
        // Show overlay toggles again when returning to simulation
        DOM_ELEMENTS.statsToggle.style.display = 'block';
        DOM_ELEMENTS.controlsToggle.style.display = 'block';
        DOM_ELEMENTS.pastRunsToggleMain.style.display = 'block';
      });
      DOM_ELEMENTS.currentRunInfo.classList.add('visible'); // Show current run info by default

        // Data Management Buttons
        DOM_ELEMENTS.exportRunsButton.addEventListener('click', exportRunsData);
        DOM_ELEMENTS.importRunsFile.addEventListener('change', importRunsData);
        if (DOM_ELEMENTS.exportBNPngButton) DOM_ELEMENTS.exportBNPngButton.addEventListener('click', exportBNAsImage);
        if (DOM_ELEMENTS.exportBNSvgButton) DOM_ELEMENTS.exportBNSvgButton.addEventListener('click', exportBNAsSVG);
    }

    function startNewRun(parametersToUse) {
      // Save data from the previous run if it was significant
      if (currentRunFrameCounter > 30) { // Only save if it ran for a bit
        saveCurrentRunData(); // This updates GP and BN with the *completed* run's data

        // Update AutoPilot stats based on the run that just *finished*
        const lastRunData = completedRuns.length > 0 ? completedRuns[completedRuns.length - 1] : null;
        if (lastRunData && lastRunData.runNumber === currentRunNumber) { // Ensure it's the correct run
          const lastRunAutoPilotScore = calculateAutoPilotScore(lastRunData);
          if (lastRunAutoPilotScore > autoPilotStats.bestScoreEver) {
            autoPilotStats.bestScoreEver = lastRunAutoPilotScore;
            autoPilotStats.stagnationCounter = 0;
            console.log(`Autopilot: New best AUTO-PILOT score ${autoPilotStats.bestScoreEver.toFixed(0)} from run ${lastRunData.runNumber}`);
          } else if (lastRunData.durationFrames > 50) { // Avoid penalizing stagnation for very short runs
            autoPilotStats.stagnationCounter++;
          }
          autoPilotStats.lastScore = lastRunAutoPilotScore;
          const bnErr = calculateBNPredictionError(lastRunData);
          if (bnErr !== null) {
            autoPilotStats.bnPredictionErrorCount++;
            autoPilotStats.bnPredictionErrorAvg += (bnErr - autoPilotStats.bnPredictionErrorAvg) / autoPilotStats.bnPredictionErrorCount;
            bnPredictionErrorHistory.errors.push(bnErr);
            if (bnPredictionErrorHistory.errors.length > bnPredictionErrorHistory.maxLength) bnPredictionErrorHistory.errors.shift();
            lastRunData.bnPredictionError = bnErr;
            if (DOM_ELEMENTS.statsOverlay.classList.contains('visible') && bnPredictionErrorGraphCanvas) {
              drawBNPredictionErrorGraph();
            }
          }
          updateAutoPilotStatsDisplay();
        }
      }

      // Clear BN prediction history for the new run
      Object.keys(bnPredictionHistory).forEach(key => {
        if (key !== 'maxLength') bnPredictionHistory[key] = [];
      });

      // Apply new parameters to the global config and UI controls
      Object.keys(parametersToUse).forEach(key => {
        if (config.hasOwnProperty(key)) config[key] = parametersToUse[key];

        // Update UI slider if it exists for this parameter
        const controlMap = allSliderControls.find(m => m.configKey === key);
        if (controlMap) {
          updateSliderAndDisplay(controlMap.id, parametersToUse[key], controlMap.precision, controlMap.type);
        } else { // Handle non-slider controls like checkboxes and simulation speed
          const checkbox = DOM_ELEMENTS[key]; // Assuming checkbox ID matches configKey
          if (checkbox && checkbox.type === 'checkbox' && typeof parametersToUse[key] === 'boolean' && config.hasOwnProperty(key)) {
            checkbox.checked = parametersToUse[key];
          } else if (key === 'simulationSpeedMultiplier' && DOM_ELEMENTS.simulationSpeed) {
            DOM_ELEMENTS.simulationSpeed.value = parametersToUse[key];
            if (DOM_ELEMENTS.simulationSpeedValue) DOM_ELEMENTS.simulationSpeedValue.textContent = parseFloat(parametersToUse[key]).toFixed(1);
          }
        }
      });

      // Explicitly update boolean config flags if not covered by loop (e.g. if key wasn't in parametersToUse but in config)
      if (DOM_ELEMENTS.planktonMode) DOM_ELEMENTS.planktonMode.checked = config.planktonMode;
      if (DOM_ELEMENTS.preyKillPredatorsMode) DOM_ELEMENTS.preyKillPredatorsMode.checked = config.preyKillPredatorsMode;
      if (DOM_ELEMENTS.simulationSpeed && DOM_ELEMENTS.simulationSpeedValue) {
        DOM_ELEMENTS.simulationSpeed.value = config.simulationSpeedMultiplier;
        DOM_ELEMENTS.simulationSpeedValue.textContent = config.simulationSpeedMultiplier.toFixed(1);
      }


      // Update derived config values (like vision radius squared)
      config.preyVisionRadiusSq = config.preyVisionRadius * config.preyVisionRadius;
      config.predatorVisionRadiusSq = config.predatorVisionRadius * config.predatorVisionRadius;

      // Increment run number and reset run-specific counters
      currentRunNumber++;
      DOM_ELEMENTS.currentRunDisplay.textContent = currentRunNumber;
      currentRunFrameCounter = 0;
      currentRunDeathFrames = { plant: null, prey: null, predator: null };
      simulationTimeAccumulator = 0; // Reset for fixed step loop

      resetSimulation(); // Resets entities, populations, and history arrays
      updateRunStartBNPredictionsDisplay(); // Show BN predictions for this run
      updateCurrentBNPredictionsDisplay(); // Update BN display for the *new* current parameters
      updateBnAccuracyDisplay();

      DOM_ELEMENTS.currentRunInfo.classList.add('visible');
      lastTimestamp = performance.now(); // Reset for game loop delta time
      simulationIsActive = true; // Ensure simulation is active

      if (!gameLoopRunning) { // If game loop was stopped, restart it
        if (animationFrameId) cancelAnimationFrame(animationFrameId); // Clear any old frame
        animationFrameId = requestAnimationFrame(gameLoop);
      }
    }

    function calculateRunScore(runData) { const params = runData.parameters; const stats = runData.statistics; const duration = runData.durationFrames; const activePopSurvivalTimes = []; if (params.initialPlants > 0) activePopSurvivalTimes.push(stats.deathFrames.plant === null ? duration : stats.deathFrames.plant); if (params.initialPrey > 0) activePopSurvivalTimes.push(stats.deathFrames.prey === null ? duration : stats.deathFrames.prey); if (params.initialPredators > 0) activePopSurvivalTimes.push(stats.deathFrames.predator === null ? duration : stats.deathFrames.predator); return activePopSurvivalTimes.length === 0 ? 0 : Math.min(...activePopSurvivalTimes); }

    function calculateAutoPilotScore(runData) {
      const params = runData.parameters;
      const stats = runData.statistics;
      const duration = runData.durationFrames;

      const MIN_DURATION_FOR_SCORING = 75; // Frames; runs shorter than this get heavy penalties
      if (duration < MIN_DURATION_FOR_SCORING) return -10000 - (MIN_DURATION_FOR_SCORING - duration) * 10;

      let score = 0;
      // Base score from simple survival duration of the "weakest link"
      score += calculateRunScore(runData) * 0.6; // Weight this component

      // Normalize events by duration (per 1000 frames) to compare runs of different lengths
      const durationFactor = duration > 0 ? 1000 / duration : 0;

      // Reward births
      score += (stats.totalPreyBirths + stats.totalPredatorBirths) * durationFactor * 25;

      // Penalize starvation heavily
      score -= stats.totalPreyDeathsByStarvation * durationFactor * 100;  // Increased penalty
      score -= stats.totalPredatorDeathsByStarvation * durationFactor * 80; // Increased penalty

      if (params.preyKillPredatorsMode) {
        score -= stats.totalPredatorDeathsByMobbing * durationFactor * 35;
      }

      // Penalize quick extinctions
      const QUICK_EXTINCTION_THRESHOLD_FACTOR = 0.2; // e.g., if dies in first 20% of MIN_DURATION
      const QUICK_EXTINCTION_PENALTY = 2500;
      if (params.initialPlants > 0 && stats.deathFrames.plant !== null && stats.deathFrames.plant < MIN_DURATION_FOR_SCORING * QUICK_EXTINCTION_THRESHOLD_FACTOR) score -= QUICK_EXTINCTION_PENALTY;
      if (params.initialPrey > 0 && stats.deathFrames.prey !== null && stats.deathFrames.prey < MIN_DURATION_FOR_SCORING * QUICK_EXTINCTION_THRESHOLD_FACTOR) score -= QUICK_EXTINCTION_PENALTY * 1.75; // Prey are crucial
      if (params.initialPredators > 0 && stats.deathFrames.predator !== null && stats.deathFrames.predator < MIN_DURATION_FOR_SCORING * QUICK_EXTINCTION_THRESHOLD_FACTOR) score -= QUICK_EXTINCTION_PENALTY;

      const PLANT_EXTINCTION_PENALTY = 1200; // Additional penalty if plants die out
      if (params.initialPlants > 0 && stats.finalPlantCount === 0) score -= PLANT_EXTINCTION_PENALTY;

      // Bonus for multiple populations surviving till the end of the run
      const ALL_ALIVE_BONUS = 1500;
      const TWO_ALIVE_BONUS = 700;
      let aliveCount = 0;
      if (params.initialPlants > 0 && (stats.deathFrames.plant === null || stats.deathFrames.plant >= duration)) aliveCount++;
      if (params.initialPrey > 0 && (stats.deathFrames.prey === null || stats.deathFrames.prey >= duration)) aliveCount++;
      if (params.initialPredators > 0 && (stats.deathFrames.predator === null || stats.deathFrames.predator >= duration)) aliveCount++;

      let initialPopTypes = 0;
      if (params.initialPlants > 0) initialPopTypes++;
      if (params.initialPrey > 0) initialPopTypes++;
      if (params.initialPredators > 0) initialPopTypes++;

      if (initialPopTypes >= 3 && aliveCount === 3) score += ALL_ALIVE_BONUS;
      else if (initialPopTypes >= 2 && aliveCount === 2) score += TWO_ALIVE_BONUS;

      // Small bonus for final populations being non-zero (even if they died before end of *max* sim time)
      if (stats.finalPreyCount > 0 && params.initialPrey > 0) score += 150;
      if (stats.finalPredatorCount > 0 && params.initialPredators > 0) score += 75;
      if (stats.finalPlantCount > 0 && params.initialPlants > 0) score += 30;

      // Penalize population instability (high variance in population counts)
      const STABILITY_ANALYSIS_MIN_FRAMES = 50; // Min frames for a population to exist to analyze its stability
      const STABILITY_PENALTY_FACTOR = 0.75; // Multiplier for std dev penalty
      const populationHistories = runData.populationGraphHistory;
      if (populationHistories) {
        const analyzeStability = (popHistoryKey, initialPop, deathFrame) => {
          const popHistData = populationHistories[popHistoryKey];
          if (!popHistData) return;

          // Only analyze if population started and survived for a minimum duration
          if (initialPop > 0 && (deathFrame === null || deathFrame > STABILITY_ANALYSIS_MIN_FRAMES)) {
            const relevantHistory = (deathFrame === null) ? popHistData : popHistData.slice(0, Math.floor(deathFrame / historyUpdateInterval));
            if (relevantHistory.length > STABILITY_ANALYSIS_MIN_FRAMES / historyUpdateInterval * 0.5) { // Need at least half of min frames in history
              const analysisWindow = relevantHistory.slice(Math.floor(relevantHistory.length / 2)); // Analyze latter half
              if (analysisWindow.length > 5) { // Need a few data points
                const meanPop = analysisWindow.reduce((s, v) => s + v, 0) / analysisWindow.length;
                if (meanPop > 5) { // Only penalize instability if average pop is somewhat significant
                  const variance = analysisWindow.reduce((s, v) => s + (v - meanPop) ** 2, 0) / analysisWindow.length;
                  const stdDev = Math.sqrt(variance);
                  score -= stdDev * STABILITY_PENALTY_FACTOR; // Penalize by std deviation
                }
              }
            }
          }
        };
        analyzeStability('prey', params.initialPrey, stats.deathFrames.prey);
        analyzeStability('predators', params.initialPredators, stats.deathFrames.predator);
      }

      // Bonus for net positive growth rates if population survived reasonably long
      const W_NET_GROWTH_BONUS = 800;
      if (params.initialPlants > 0 && duration > 0) {
        const plantBirthRate = stats.totalPlantBirths / duration;
        const plantConsumptionRate = stats.totalPlantsConsumed / duration;
        const plantNetGrowthPositive = plantBirthRate > plantConsumptionRate;
        if (plantNetGrowthPositive) score += W_NET_GROWTH_BONUS * (stats.finalPlantCount > params.initialPlants * 0.8 ? 1.1 : 1); // Slightly higher bonus if final pop is good
      }

      if (params.initialPrey > 0 && duration > 0) {
        const preyBirthRate = stats.totalPreyBirths / duration;
        const preyDeathRateTotal = (stats.totalPreyDeathsByPredation + stats.totalPreyDeathsByStarvation) / duration;
        if (preyBirthRate > preyDeathRateTotal) score += W_NET_GROWTH_BONUS * 1.2 * (stats.finalPreyCount > params.initialPrey * 0.8 ? 1.1 : 1);
      }
      if (params.initialPredators > 0 && duration > 0) {
        const predBirthRate = stats.totalPredatorBirths / duration;
        const predDeathRateTotal = (stats.totalPredatorDeathsByStarvation + stats.totalPredatorDeathsByMobbing) / duration;
        if (predBirthRate > predDeathRateTotal) score += W_NET_GROWTH_BONUS * (stats.finalPredatorCount > params.initialPredators * 0.8 ? 1.1 : 1);
      }
      return score;
    }

    function calculateBNPredictionError(runData) {
      const preds = runData.statistics.bnPredictionsAtRunStart;
      if (!preds || preds.extinction?.error || preds.growth?.error || preds.starvationRisk?.error) return null;

      const p = runData.parameters;
      const s = runData.statistics;
      const duration = runData.durationFrames > 0 ? runData.durationFrames : 1;

      const outcomes = {
        preyExtinct: p.initialPrey > 0 && s.deathFrames.prey !== null,
        predatorExtinct: p.initialPredators > 0 && s.deathFrames.predator !== null,
        growPlant: (s.totalPlantBirths / duration) > (s.totalPlantsConsumed / duration),
        growPrey: (s.totalPreyBirths / duration) > ((s.totalPreyDeathsByPredation + s.totalPreyDeathsByStarvation) / duration),
        growPredator: (s.totalPredatorBirths / duration) > ((s.totalPredatorDeathsByStarvation + s.totalPredatorDeathsByMobbing) / duration),
        starvPrey: (() => {
          const frac = s.totalPreyDeathsByStarvation / Math.max(1, s.totalPreyDeathsByPredation + s.totalPreyDeathsByStarvation);
          const rate = (s.totalPreyDeathsByStarvation / duration) / Math.max(1, p.initialPrey);
          return (frac > 0.70 && (s.totalPreyDeathsByPredation + s.totalPreyDeathsByStarvation) > 5) ||
            (rate > 0.003 && p.initialPrey > 5 && duration > 100);
        })(),
        starvPred: (() => {
          const frac = s.totalPredatorDeathsByStarvation / Math.max(1, s.totalPredatorDeathsByStarvation + s.totalPredatorDeathsByMobbing);
          const rate = (s.totalPredatorDeathsByStarvation / duration) / Math.max(1, p.initialPredators);
          return (frac > 0.70 && (s.totalPredatorDeathsByStarvation + s.totalPredatorDeathsByMobbing) > 2) ||
            (rate > 0.004 && p.initialPredators > 2 && duration > 100);
        })(),
      };

      const diffs = [
        Math.abs(preds.extinction.prey - (outcomes.preyExtinct ? 1 : 0)),
        Math.abs(preds.extinction.predator - (outcomes.predatorExtinct ? 1 : 0)),
        Math.abs(preds.growth.plant - (outcomes.growPlant ? 1 : 0)),
        Math.abs(preds.growth.prey - (outcomes.growPrey ? 1 : 0)),
        Math.abs(preds.growth.predator - (outcomes.growPredator ? 1 : 0)),
        Math.abs(preds.starvationRisk.prey - (outcomes.starvPrey ? 1 : 0)),
        Math.abs(preds.starvationRisk.predator - (outcomes.starvPred ? 1 : 0)),
      ];
      return diffs.reduce((a, b) => a + b, 0) / diffs.length;
    }

    function perturbParameter(currentValue, paramConfig, explorationFactor) { let { min, max, step, p_factor, type } = paramConfig; if (step <= 0) step = (type === 'int' ? 1 : 0.01); let effectivePFactor = p_factor * (1.0 + explorationFactor * 0.75); const range = max - min; let perturbation; if (Math.random() < (0.2 + explorationFactor * 0.5) || ((currentValue - min < range * 0.1 || max - currentValue < range * 0.1) && Math.random() < 0.25)) { perturbation = Math.max(step, range * random(0.05, 0.20 + explorationFactor * 0.15)); } else { perturbation = Math.max(step, Math.abs(currentValue * effectivePFactor)); } perturbation = Math.round(perturbation / step) * step; if (perturbation === 0 && step > 0) perturbation = step; let newValue = currentValue + (Math.random() < 0.5 ? -1 : 1) * perturbation; const precision = getPrecision(step); newValue = type === 'int' ? Math.round(newValue / step) * step : parseFloat((Math.round(newValue / step) * step).toFixed(precision)); return Math.max(min, Math.min(max, newValue)); }
    function ensureHealthParamConsistency(params) { const healthConfigs = [{ maxKey: 'preyMaxHealth', reproKey: 'preyHealthToReproduce', margin: 20 }, { maxKey: 'predatorMaxHealth', reproKey: 'predatorHealthToReproduce', margin: 20 }]; healthConfigs.forEach(hc => { const maxParamInfo = tunableParams.find(p => p.configKey === hc.maxKey); const reproParamInfo = tunableParams.find(p => p.configKey === hc.reproKey); if (!maxParamInfo || !reproParamInfo) return; let maxHealth = params[hc.maxKey]; let healthToRepro = params[hc.reproKey]; if (healthToRepro >= maxHealth - hc.margin) healthToRepro = maxHealth - hc.margin; healthToRepro = Math.max(reproParamInfo.min, Math.min(reproParamInfo.max, healthToRepro)); if (maxHealth < healthToRepro + hc.margin) maxHealth = healthToRepro + hc.margin; maxHealth = Math.max(maxParamInfo.min, Math.min(maxParamInfo.max, maxHealth)); if (healthToRepro >= maxHealth - hc.margin) { healthToRepro = maxHealth - hc.margin; healthToRepro = Math.max(reproParamInfo.min, Math.min(reproParamInfo.max, healthToRepro)); } params[hc.maxKey] = Math.round(maxHealth / maxParamInfo.step) * maxParamInfo.step; params[hc.reproKey] = Math.round(healthToRepro / reproParamInfo.step) * reproParamInfo.step; }); return params; }

    function suggestNextParameters() {
      let baseConfigForPerturbation;
      const normalizedGpVar = (gpOptimizer && gpOptimizer.GP_MAX_VARIANCE) ? autoPilotStats.lastGpVariance / gpOptimizer.GP_MAX_VARIANCE : 0;
      const bnErrAvg = autoPilotStats.bnPredictionErrorAvg || 0;
      const modelUncertainty = clamp((normalizedGpVar + bnErrAvg) / 2, 0, 1);
      autoPilotStats.modelUncertainty = modelUncertainty;
      const explorationFactor = clamp(autoPilotStats.stagnationCounter / 15 + modelUncertainty, 0, 1);
      if (DOM_ELEMENTS.explorationFactorDisplay)
        DOM_ELEMENTS.explorationFactorDisplay.textContent = explorationFactor.toFixed(2);
      const KAPPA_UCB = 1.0 + explorationFactor * 2.5;

      function getCandidateProportions(exp) {
        return {
          perturb: AUTOPILOT_PROPORTION_PERTURB * (1 - exp * 0.2),
          perturbReset: AUTOPILOT_PROPORTION_PERTURB_RESET,
          random: AUTOPILOT_PROPORTION_RANDOM + exp * 0.15,
          crossover: AUTOPILOT_PROPORTION_CROSSOVER + exp * 0.05,
        };
      }

      const dynProps = getCandidateProportions(explorationFactor);

      const validRunsForBase = completedRuns
        .map(r => ({ ...r, autoPilotScore: calculateAutoPilotScore(r) }))
        .filter(r => r.durationFrames > 30 && r.autoPilotScore > -9000);

      if (validRunsForBase.length < gpOptimizer.MIN_OBS_FOR_GP_ESTIMATE || Math.random() < explorationFactor * 0.20) {
        baseConfigForPerturbation = structuredClone(initialConfigSnapshot || config);
      } else {
        const minObservedScore = Math.min(0, ...validRunsForBase.map(r => r.autoPilotScore));
        const weightedRuns = validRunsForBase.map(r => ({ item: r, weight: Math.pow(r.autoPilotScore - minObservedScore + 1, 1.75) }));
        const selectedRun = weightedRandomSelect(weightedRuns);
        baseConfigForPerturbation = selectedRun ? structuredClone(selectedRun.parameters) : structuredClone(config);
      }

      const candidates = [];

      for (let i = 0; i < Math.floor(AUTOPILOT_CANDIDATE_POOL_SIZE * dynProps.perturb); i++) {
        let candidateParams = structuredClone(baseConfigForPerturbation);
        const numParamsToChange = randomInt(1, Math.max(1, Math.floor(tunableParams.length * (0.15 + explorationFactor * 0.4))));
        const shuffledTunable = [...tunableParams].sort(() => 0.5 - Math.random());
        for (let j = 0; j < numParamsToChange; j++) {
          const param = shuffledTunable[j];
          candidateParams[param.configKey] = perturbParameter(candidateParams[param.configKey] ?? param.min, param, explorationFactor);
        }
        // Autopilot can still try different boolean flags for exploration
        if (candidateParams.hasOwnProperty('planktonMode')) candidateParams.planktonMode = Math.random() < (0.15 + explorationFactor * 0.25) ? !baseConfigForPerturbation.planktonMode : baseConfigForPerturbation.planktonMode;
        if (candidateParams.hasOwnProperty('preyKillPredatorsMode')) candidateParams.preyKillPredatorsMode = Math.random() < (0.15 + explorationFactor * 0.25) ? !baseConfigForPerturbation.preyKillPredatorsMode : baseConfigForPerturbation.preyKillPredatorsMode;

        candidateParams = ensureHealthParamConsistency(candidateParams);
        candidates.push({ params: candidateParams, score: 0, source: 'perturb' });
      }

      for (let i = 0; i < Math.floor(AUTOPILOT_CANDIDATE_POOL_SIZE * dynProps.perturbReset); i++) {
        let candidateParams = structuredClone(baseConfigForPerturbation);
        const numParamsToChange = randomInt(1, Math.max(1, Math.floor(tunableParams.length * (0.2 + explorationFactor * 0.3))));
        const numParamsToReset = randomInt(0, Math.max(1, Math.floor(numParamsToChange * (0.2 + explorationFactor * 0.3))));
        const shuffledTunable = [...tunableParams].sort(() => 0.5 - Math.random());
        for (let j = 0; j < numParamsToChange; j++) {
          const param = shuffledTunable[j];
          if (j < numParamsToReset && initialConfigSnapshot) {
            if (Math.random() < 0.6 && initialConfigSnapshot[param.configKey] !== undefined) {
              candidateParams[param.configKey] = initialConfigSnapshot[param.configKey];
            } else {
              let val = random(param.min, param.max);
              if (param.type === 'int') val = Math.round(val / param.step) * param.step;
              else val = parseFloat(val.toFixed(getPrecision(param.step)));
              candidateParams[param.configKey] = Math.max(param.min, Math.min(param.max, val));
            }
          } else {
            candidateParams[param.configKey] = perturbParameter(candidateParams[param.configKey] ?? param.min, param, explorationFactor * 1.1);
          }
        }
        if (candidateParams.hasOwnProperty('planktonMode')) candidateParams.planktonMode = Math.random() < (0.2 + explorationFactor * 0.3) ? Math.random() < 0.5 : baseConfigForPerturbation.planktonMode;
        if (candidateParams.hasOwnProperty('preyKillPredatorsMode')) candidateParams.preyKillPredatorsMode = Math.random() < (0.2 + explorationFactor * 0.3) ? Math.random() < 0.5 : baseConfigForPerturbation.preyKillPredatorsMode;
        candidateParams = ensureHealthParamConsistency(candidateParams);
        candidates.push({ params: candidateParams, score: 0, source: 'perturb_reset' });
      }


      for (let i = 0; i < Math.floor(AUTOPILOT_CANDIDATE_POOL_SIZE * dynProps.random); i++) {
        let randomParams = {};
        tunableParams.forEach(p => {
          let val = random(p.min, p.max);
          if (p.type === 'int') val = Math.round(val / p.step) * p.step;
          else val = parseFloat(val.toFixed(getPrecision(p.step)));
          randomParams[p.configKey] = Math.max(p.min, Math.min(p.max, val));
        });
        randomParams.planktonMode = Math.random() < 0.5;
        randomParams.preyKillPredatorsMode = Math.random() < 0.5;
        randomParams = ensureHealthParamConsistency(randomParams);
        candidates.push({ params: randomParams, score: 0, source: 'random' });
      }

      if (validRunsForBase.length >= 2) {
        const numCrossoverCandidates = Math.floor(AUTOPILOT_CANDIDATE_POOL_SIZE * dynProps.crossover);
        for (let i = 0; i < numCrossoverCandidates; i++) {
          const parent1Run = weightedRandomSelect(validRunsForBase.map(r => ({ item: r, weight: Math.max(1, r.autoPilotScore - (autoPilotStats.lastScore - 200)) })));
          let parent2Run = weightedRandomSelect(validRunsForBase.map(r => ({ item: r, weight: Math.max(1, r.autoPilotScore - (autoPilotStats.lastScore - 200)) })));
          let attempts = 0;
          while (parent1Run && parent2Run && parent1Run.runNumber === parent2Run.runNumber && attempts < 10 && validRunsForBase.length > 1) {
            parent2Run = weightedRandomSelect(validRunsForBase.map(r => ({ item: r, weight: Math.max(1, r.autoPilotScore - (autoPilotStats.lastScore - 200)) })));
            attempts++;
          }

          if (parent1Run && parent2Run && parent1Run.runNumber !== parent2Run.runNumber) {
            const parent1Params = parent1Run.parameters;
            const parent2Params = parent2Run.parameters;
            let childParams = {};
            tunableParams.forEach(pConf => {
              childParams[pConf.configKey] = Math.random() < 0.5 ? parent1Params[pConf.configKey] : parent2Params[pConf.configKey];
            });
            if (parent1Params.hasOwnProperty('planktonMode') && parent2Params.hasOwnProperty('planktonMode')) childParams.planktonMode = Math.random() < 0.5 ? parent1Params.planktonMode : parent2Params.planktonMode; else childParams.planktonMode = Math.random() < 0.5;
            if (parent1Params.hasOwnProperty('preyKillPredatorsMode') && parent2Params.hasOwnProperty('preyKillPredatorsMode')) childParams.preyKillPredatorsMode = Math.random() < 0.5 ? parent1Params.preyKillPredatorsMode : parent2Params.preyKillPredatorsMode; else childParams.preyKillPredatorsMode = Math.random() < 0.5;

            if (Math.random() < 0.3 + explorationFactor * 0.2) {
              const paramToMutate = tunableParams[randomInt(0, tunableParams.length - 1)];
              childParams[paramToMutate.configKey] = perturbParameter(childParams[paramToMutate.configKey], paramToMutate, explorationFactor * 0.5);
            }
            childParams = ensureHealthParamConsistency(childParams);
            candidates.push({ params: childParams, score: 0, source: 'crossover' });
          } else if (numCrossoverCandidates > 0 && i > 0) { i--; }
        }
      }

      while (candidates.length < AUTOPILOT_CANDIDATE_POOL_SIZE) {
        let randomParams = {};
        tunableParams.forEach(p => {
          let val = random(p.min, p.max);
          if (p.type === 'int') val = Math.round(val / p.step) * p.step;
          else val = parseFloat(val.toFixed(getPrecision(p.step)));
          randomParams[p.configKey] = Math.max(p.min, Math.min(p.max, val));
        });
        randomParams.planktonMode = Math.random() < 0.5;
        randomParams.preyKillPredatorsMode = Math.random() < 0.5;
        randomParams = ensureHealthParamConsistency(randomParams);
        candidates.push({ params: randomParams, score: 0, source: 'random_fill' });
      }

      const SCORE_WEIGHT_EXTINCTION_PENALTY_SQUARED = 9000;
      const SCORE_WEIGHT_STARVATION_RISK_PENALTY_SQUARED = 7000;
      const SCORE_WEIGHT_GROWTH_BONUS = 1200;
      const SCORE_WEIGHT_ALL_GROWTH_BONUS_FACTOR = 2.2;

      function computeAdaptiveWeights() {
        const modelUnc = clamp(autoPilotStats.modelUncertainty ?? 0, 0, 1);
        const bnAvgErr = clamp(autoPilotStats.bnPredictionErrorAvg ?? 0.5, 0, 1);
        return {
          gp: 0.40 * (1 - modelUnc),
          ucb: 0.20 * (1 + modelUnc),
          bn: 0.40 * Math.max(0, 1 - bnAvgErr)
        };
      }

      const { gp: GP_MEAN_WEIGHT, ucb: UCB_BONUS_WEIGHT, bn: BN_SCORE_WEIGHT } = computeAdaptiveWeights();

      candidates.forEach(c => {
        let gpMean = 0;
        let gpVariance = (gpOptimizer && gpOptimizer.GP_MAX_VARIANCE !== undefined) ? gpOptimizer.GP_MAX_VARIANCE : 1.0;
        let rawBnScore = 0;

        if (isBNReady()) {
          const bnExtPreds = predictExtinctionProbabilities(c.params);
          const bnGrowthPreds = predictFavorableGrowth(c.params);
          const bnStarvPreds = predictStarvationRiskProbabilities(c.params);

          let activeSpeciesCountBN = 0;
          let allActiveSpeciesFavorableGrowthBN = true;

          if (!bnExtPreds.error) {
            if (c.params.initialPrey > 0) rawBnScore -= Math.pow(bnExtPreds.prey, 2) * SCORE_WEIGHT_EXTINCTION_PENALTY_SQUARED;
            if (c.params.initialPredators > 0) rawBnScore -= Math.pow(bnExtPreds.predator, 2) * SCORE_WEIGHT_EXTINCTION_PENALTY_SQUARED;
          }
          if (!bnGrowthPreds.error) {
            if (c.params.initialPlants > 0) { activeSpeciesCountBN++; rawBnScore += bnGrowthPreds.plant * SCORE_WEIGHT_GROWTH_BONUS; if (bnGrowthPreds.plant < BN_AUTOPILOT_PREDICTION_THRESHOLD) allActiveSpeciesFavorableGrowthBN = false; }
            if (c.params.initialPrey > 0) { activeSpeciesCountBN++; rawBnScore += bnGrowthPreds.prey * SCORE_WEIGHT_GROWTH_BONUS; if (bnGrowthPreds.prey < BN_AUTOPILOT_PREDICTION_THRESHOLD) allActiveSpeciesFavorableGrowthBN = false; }
            if (c.params.initialPredators > 0) { activeSpeciesCountBN++; rawBnScore += bnGrowthPreds.predator * SCORE_WEIGHT_GROWTH_BONUS; if (bnGrowthPreds.predator < BN_AUTOPILOT_PREDICTION_THRESHOLD) allActiveSpeciesFavorableGrowthBN = false; }
          } else { allActiveSpeciesFavorableGrowthBN = false; }

          if (activeSpeciesCountBN > 0 && allActiveSpeciesFavorableGrowthBN) {
            rawBnScore += SCORE_WEIGHT_GROWTH_BONUS * SCORE_WEIGHT_ALL_GROWTH_BONUS_FACTOR;
          }
          if (!bnStarvPreds.error) {
            if (c.params.initialPrey > 0) rawBnScore -= Math.pow(bnStarvPreds.prey, 2) * SCORE_WEIGHT_STARVATION_RISK_PENALTY_SQUARED;
            if (c.params.initialPredators > 0) rawBnScore -= Math.pow(bnStarvPreds.predator, 2) * SCORE_WEIGHT_STARVATION_RISK_PENALTY_SQUARED;
          }

        }
        c.debug_bn_component = rawBnScore;

        if (gpOptimizer && gpOptimizer.observations.length >= gpOptimizer.MIN_OBS_FOR_GP_ESTIMATE) {
          const gpPrediction = gpOptimizer.predict(c.params);
          gpMean = gpPrediction.mean;
          gpVariance = gpPrediction.variance;

          const ucbScoreMagnitudeHeuristic = Math.abs(gpMean) * 0.15 + 100;

          c.score = gpMean * GP_MEAN_WEIGHT +
            KAPPA_UCB * Math.sqrt(gpVariance) * ucbScoreMagnitudeHeuristic * UCB_BONUS_WEIGHT +
            rawBnScore * BN_SCORE_WEIGHT;
        } else {
          const BN_SCORE_WEIGHT_NO_GP = 0.85;
          const RANDOM_EXPLORATION_WEIGHT_NO_GP = 0.15;
          const randomExplorationMagnitude = (autoPilotStats.bestScoreEver !== -Infinity && autoPilotStats.bestScoreEver !== 0)
            ? Math.abs(autoPilotStats.bestScoreEver * 0.1)
            : 500;
          c.score = rawBnScore * BN_SCORE_WEIGHT_NO_GP +
            (Math.random() - 0.5) * randomExplorationMagnitude * RANDOM_EXPLORATION_WEIGHT_NO_GP;
        }
        c.debug_gp_mean = gpMean;
        c.debug_gp_variance = gpVariance;
      });

      candidates.sort((a, b) => b.score - a.score);
      const bestCandidate = candidates[0];
      autoPilotStats.lastGpVariance = bestCandidate.debug_gp_variance;

      bnPredictionsForNextRun = {
        extinction: isBNReady() ? predictExtinctionProbabilities(bestCandidate.params) : { plant: 0.5, prey: 0.5, predator: 0.5, error: "BN not ready" },
        growth: isBNReady() ? predictFavorableGrowth(bestCandidate.params) : { plant: 0.5, prey: 0.5, predator: 0.5, error: "BN not ready" },
        starvationRisk: isBNReady() ? predictStarvationRiskProbabilities(bestCandidate.params) : { prey: 0.5, predator: 0.5, error: "BN not ready" },
      };


      console.log(`Autopilot selected (Source: ${bestCandidate.source}). Top Score: ${bestCandidate.score.toFixed(0)}. Weights -> BN:${BN_SCORE_WEIGHT.toFixed(2)} GP:${GP_MEAN_WEIGHT.toFixed(2)} UCB:${UCB_BONUS_WEIGHT.toFixed(2)}. Stag:${autoPilotStats.stagnationCounter}, ModelUncert:${autoPilotStats.modelUncertainty.toFixed(2)} BNErr:${autoPilotStats.bnPredictionErrorAvg.toFixed(3)}, Exploration:${explorationFactor.toFixed(2)}, Kappa:${KAPPA_UCB.toFixed(2)}`);

      console.log(`  GP Pred: Mean=${bestCandidate.debug_gp_mean.toFixed(0)}, Var=${bestCandidate.debug_gp_variance.toFixed(3)}. BN Comp: ${bestCandidate.debug_bn_component.toFixed(0)}`);
      if (bnPredictionsForNextRun.extinction && bnPredictionsForNextRun.growth && bnPredictionsForNextRun.starvationRisk) {
        console.log(`  BN Preds for chosen: ExtP:${bnPredictionsForNextRun.extinction.prey?.toFixed(3)} ExtR:${bnPredictionsForNextRun.extinction.predator?.toFixed(3)} | GrowPl:${bnPredictionsForNextRun.growth.plant?.toFixed(3)} GrowP:${bnPredictionsForNextRun.growth.prey?.toFixed(3)} GrowR:${bnPredictionsForNextRun.growth.predator?.toFixed(3)} | StarvP:${bnPredictionsForNextRun.starvationRisk.prey?.toFixed(3)} StarvR:${bnPredictionsForNextRun.starvationRisk.predator?.toFixed(3)}`);
      }

      let finalParamsToReturn = { ...initialConfigSnapshot };

      tunableParams.forEach(tp => {
        if (bestCandidate.params.hasOwnProperty(tp.configKey)) {
          finalParamsToReturn[tp.configKey] = bestCandidate.params[tp.configKey];
        }
      });

      // Persist these specific parameters from the current UI state (global config)
      finalParamsToReturn.simulationSpeedMultiplier = config.simulationSpeedMultiplier;
      finalParamsToReturn.planktonMode = config.planktonMode;
      finalParamsToReturn.preyKillPredatorsMode = config.preyKillPredatorsMode;

      // Ensure all keys from the original config are present, filling any gaps
      for (const key in config) {
        if (!finalParamsToReturn.hasOwnProperty(key) && config.hasOwnProperty(key)) {
          finalParamsToReturn[key] = config[key];
        }
      }

      finalParamsToReturn = ensureHealthParamConsistency(finalParamsToReturn);
      return finalParamsToReturn;
    }

    function saveCurrentRunData() {
      const currentFullConfig = structuredClone(config);
      currentFullConfig.preyVisionRadiusSq = currentFullConfig.preyVisionRadius * currentFullConfig.preyVisionRadius;
      currentFullConfig.predatorVisionRadiusSq = currentFullConfig.predatorVisionRadius * currentFullConfig.predatorVisionRadius;

      const runData = {
        runNumber: currentRunNumber,
        durationFrames: currentRunFrameCounter,
        parameters: currentFullConfig,
        statistics: {
          totalPlantBirths, totalPlantsConsumed, totalPreyBirths, totalPredatorBirths,
          totalPreyDeathsByPredation, totalPreyDeathsByStarvation,
          totalPredatorDeathsByStarvation, totalPredatorDeathsByMobbing,
          finalPlantCount: plants.length, finalPreyCount: prey.length, finalPredatorCount: predators.length,
          deathFrames: structuredClone(currentRunDeathFrames),
          bnPredictionsAtRunStart: structuredClone(bnPredictionsForNextRun),
        },
        populationGraphHistory: structuredClone(populationHistory),
        cumulativeGraphHistory: structuredClone(cumulativeHistory),
        bnPredictionGraphHistory: structuredClone(bnPredictionHistory),
      };
      completedRuns.push(runData);

      const brier = computeBNPredictionError(runData);
      if (brier !== null) {
        bnPredictionErrors.push(brier);
        if (bnPredictionErrors.length > BN_ERROR_HISTORY_LENGTH) bnPredictionErrors.shift();
        runData.statistics.bnPredictionBrierScore = brier;
        updateBnAccuracyDisplay();
      }

      if (gpOptimizer && runData.durationFrames > 30) {
        const scoreForGP = calculateAutoPilotScore(runData);
        gpOptimizer.addObservation(runData.parameters, scoreForGP);
      }
      if (simBayesianNetwork && currentRunFrameCounter > 30) {
        updateBNWithRunData(runData);
      }

      adaptBNBinCountIfNeeded();
    }

    function drawSinglePastRunSummaryGraph(canvasEl, runData) {
    if (!canvasEl || !runData || !runData.populationGraphHistory) return;
    canvasEl.width = canvasEl.clientWidth || 280;
    canvasEl.height = 100;
    const summaryGraphCtx = canvasEl.getContext('2d');
    const popHistories = [{
        data: runData.populationGraphHistory.plants,
        color: getComputedCssVar(CSS_VARS.PLANT_COLOR),
        lineWidth: 1.5
    }, {
        data: runData.populationGraphHistory.prey,
        color: getComputedCssVar(CSS_VARS.PREY_COLOR),
        lineWidth: 1.5
    }, {
        data: runData.populationGraphHistory.predators,
        color: getComputedCssVar(CSS_VARS.PREDATOR_COLOR),
        lineWidth: 1.5
    }, ];
    drawSimplifiedGenericGraph(summaryGraphCtx, canvasEl, popHistories, runData.populationGraphHistory.maxLength);
}

    function updateRunStartBNPredictionsDisplay() {
      if (!bnPredictionsForNextRun) return;
      const ext = bnPredictionsForNextRun.extinction;
      const grow = bnPredictionsForNextRun.growth;
      const starv = bnPredictionsForNextRun.starvationRisk;
      DOM_ELEMENTS.bnRunStartPreyExtinctionPrediction.textContent = ext && !ext.error ? ext.prey.toFixed(3) : 'N/A';
      DOM_ELEMENTS.bnRunStartPredatorExtinctionPrediction.textContent = ext && !ext.error ? ext.predator.toFixed(3) : 'N/A';
      DOM_ELEMENTS.bnRunStartPlantGrowthPrediction.textContent = grow && !grow.error ? grow.plant.toFixed(3) : 'N/A';
      DOM_ELEMENTS.bnRunStartPreyGrowthPrediction.textContent = grow && !grow.error ? grow.prey.toFixed(3) : 'N/A';
      DOM_ELEMENTS.bnRunStartPredatorGrowthPrediction.textContent = grow && !grow.error ? grow.predator.toFixed(3) : 'N/A';
      DOM_ELEMENTS.bnRunStartPreyStarvationRiskPrediction.textContent = starv && !starv.error ? starv.prey.toFixed(3) : 'N/A';
      DOM_ELEMENTS.bnRunStartPredStarvationRiskPrediction.textContent = starv && !starv.error ? starv.predator.toFixed(3) : 'N/A';
    }

function updateBnAccuracyDisplay() {
      if (!DOM_ELEMENTS.bnAccuracyDisplay) return;
      const avgErr = getBnErrorAverage();
      DOM_ELEMENTS.bnAccuracyDisplay.textContent = isNaN(avgErr) ? 'N/A' : (1 - avgErr).toFixed(3);
    }

    function updateAutoPilotStatsDisplay() {
      if (DOM_ELEMENTS.autoPilotLastScoreDisplay)
        DOM_ELEMENTS.autoPilotLastScoreDisplay.textContent =
          isFinite(autoPilotStats.lastScore) ? autoPilotStats.lastScore.toFixed(0) : 'N/A';
      if (DOM_ELEMENTS.autoPilotBestScoreDisplay)
        DOM_ELEMENTS.autoPilotBestScoreDisplay.textContent =
          (autoPilotStats.bestScoreEver === -Infinity || isNaN(autoPilotStats.bestScoreEver))
            ? 'N/A'
            : autoPilotStats.bestScoreEver.toFixed(0);
      if (DOM_ELEMENTS.bnErrorAvgDisplay)
        DOM_ELEMENTS.bnErrorAvgDisplay.textContent =
          isNaN(autoPilotStats.bnPredictionErrorAvg) ? 'N/A' : autoPilotStats.bnPredictionErrorAvg.toFixed(3);
    }

    function formatBNPredictionSummary(preds) {
      if (!preds || preds.extinction?.error || preds.growth?.error || preds.starvationRisk?.error)
        return 'Preds: N/A';
      const ext = preds.extinction;
      const grow = preds.growth;
      const starv = preds.starvationRisk;
      return `Preds: ExtP ${ext.prey.toFixed(2)}, ExtR ${ext.predator.toFixed(2)} | ` +
             `GrowPl ${grow.plant.toFixed(2)}, GrowP ${grow.prey.toFixed(2)}, ` +
             `GrowR ${grow.predator.toFixed(2)} | ` +
             `StarvP ${starv.prey.toFixed(2)}, StarvR ${starv.predator.toFixed(2)}`;
    }

function populatePastRunsSummaryList() {
    const summaryListDiv = DOM_ELEMENTS.pastRunsSummaryList;
    const noRunsMessage = DOM_ELEMENTS.noPastRunsMessage;
    summaryListDiv.innerHTML = '';
    if (completedRuns.length === 0) {
        noRunsMessage.style.display = 'block';
        bnVisualizationContainer.style.display = 'none';
        return;
    }
    noRunsMessage.style.display = 'none';
    if (simBayesianNetwork) {
        bnVisualizationContainer.style.display = 'block';
        setTimeout(() => {
            drawBayesianNetworkVisualization();
            populateBNLegend();
        }, 0);
    }
    const sortedRuns = [...completedRuns].map(run => ({
        ...run,
        survivalScore: calculateRunScore(run),
        autoPilotScore: calculateAutoPilotScore(run)
    })).sort((a, b) => b.autoPilotScore - a.autoPilotScore);
    sortedRuns.forEach((run) => {
        const item = document.createElement('div');
        item.className = 'past-run-summary-item';
        const originalRunIndex = completedRuns.findIndex(r => r.runNumber === run.runNumber);
        item.dataset.runIndex = originalRunIndex;
        const predSummary = formatBNPredictionSummary(run.statistics.bnPredictionsAtRunStart);
        item.innerHTML = ` <h4 class="font-semibold text-lg">Run ${run.runNumber} (AP Score: ${run.autoPilotScore.toFixed(0)})</h4> <p class="text-sm text-gray-300">Survival: ${run.survivalScore.toFixed(0)} frames</p> <p class="text-sm text-gray-400">Final Pop: P:${run.statistics.finalPlantCount}, Y:${run.statistics.finalPreyCount}, R:${run.statistics.finalPredatorCount}</p> <p class="text-xs text-gray-400">${predSummary}</p> <canvas class="past-run-summary-graph"></canvas>`;
        summaryListDiv.appendChild(item);
        const summaryGraphCanvas = item.querySelector('.past-run-summary-graph');
        drawSinglePastRunSummaryGraph(summaryGraphCanvas, run);
        item.addEventListener('click', () => {
            const currentlySelected = summaryListDiv.querySelector('.past-run-summary-item.active-selection');
            if (currentlySelected) currentlySelected.classList.remove('active-selection');
            item.classList.add('active-selection');
            displayPastRunDetails(parseInt(item.dataset.runIndex));
        });
    });
}

function createLegendItem(historyObj, onToggle) {
    const item = document.createElement('div');
    item.className = 'legend-item';
    const swatch = document.createElement('span');
    swatch.className = 'legend-color-swatch';
    swatch.style.backgroundColor = historyObj.color;
    item.appendChild(swatch);
    item.appendChild(document.createTextNode(historyObj.label));
    if (onToggle) {
        item.addEventListener('click', () => {
            historyObj.visible = historyObj.visible === false ? true : false;
            if (historyObj.visible) item.classList.remove('disabled');
            else item.classList.add('disabled');
            onToggle();
        });
    }
    return item;
}

function populateGraphLegend(legendDivId, historiesWithLabels, onToggle) {
    const legendDiv = DOM_ELEMENTS[legendDivId];
    if (!legendDiv) return;
    legendDiv.innerHTML = '';
    historiesWithLabels.forEach(item => {
        legendDiv.appendChild(createLegendItem(item, onToggle));
        if (item.visible === false) {
            legendDiv.lastChild.classList.add('disabled');
        }
    });
}

function displayPastRunDetails(runIndex) {
    const runData = completedRuns[runIndex];
    if (!runData) return;
    DOM_ELEMENTS.pastRunDetails.style.display = 'block';
    DOM_ELEMENTS.pastRunNumberDisplay.textContent = runData.runNumber;
    DOM_ELEMENTS.pastRunScoreDisplay.textContent = calculateRunScore(runData).toFixed(0);
    DOM_ELEMENTS.pastRunAutoPilotScoreDisplay.textContent = calculateAutoPilotScore(runData).toFixed(0);
    let paramsHtml = '<ul>';
    const sortedParamKeys = Object.keys(runData.parameters).sort();
    for (const key of sortedParamKeys) {
        let friendlyKey = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
        let value = runData.parameters[key];
        let baseValue = initialConfigSnapshot ? initialConfigSnapshot[key] : undefined;
        let displayValue = value;
        const paramDef = tunableParams.find(p => p.configKey === key);
        const precision = paramDef ? getPrecision(paramDef.step) : (typeof value === 'number' && !Number.isInteger(value) ? 4 : 0);
        if (typeof value === 'number' && !Number.isInteger(value)) displayValue = parseFloat(value.toFixed(precision));
        if (baseValue !== undefined && typeof baseValue === 'number' && !Number.isInteger(baseValue)) baseValue = parseFloat(baseValue.toFixed(precision));
        let diffIndicator = '';
        if (initialConfigSnapshot && initialConfigSnapshot.hasOwnProperty(key) && JSON.stringify(value) !== JSON.stringify(baseValue)) {
            diffIndicator = ` <span class="param-diff">(Dataset Default: ${baseValue === undefined ? 'N/A' : baseValue})</span>`;
        }
        paramsHtml += `<li><strong>${friendlyKey}:</strong> ${displayValue}${diffIndicator}</li>`;
    }
    paramsHtml += '</ul>';
    DOM_ELEMENTS.pastRunParamsDisplay.innerHTML = paramsHtml;
    let statsHtml = '<ul>';
    const statDetails = runData.statistics;
    statsHtml += `<li><strong>Duration:</strong> ${runData.durationFrames} frames</li>`;
    statsHtml += `<li><strong>Initial Pop:</strong> P:${runData.parameters.initialPlants}, Y:${runData.parameters.initialPrey}, R:${runData.parameters.initialPredators}</li>`;
    let deathFramesText = `Plants: ${statDetails.deathFrames.plant ?? `Survived (${runData.durationFrames})`}`;
    deathFramesText += `, Prey: ${statDetails.deathFrames.prey ?? `Survived (${runData.durationFrames})`}`;
    deathFramesText += `, Preds: ${statDetails.deathFrames.predator ?? `Survived (${runData.durationFrames})`}`;
    statsHtml += `<li><strong>Pop End Frames:</strong> ${deathFramesText}</li>`;
    ['totalPlantBirths', 'totalPlantsConsumed', 'totalPreyBirths', 'totalPredatorBirths', 'totalPreyDeathsByPredation', 'totalPreyDeathsByStarvation', 'totalPredatorDeathsByStarvation', 'totalPredatorDeathsByMobbing'].forEach(key => {
        statsHtml += `<li><strong>${key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}:</strong> ${statDetails[key]}</li>`;
    });
    statsHtml += `<li><strong>Final Pop (P,Y,R):</strong> ${statDetails.finalPlantCount}, ${statDetails.finalPreyCount}, ${statDetails.finalPredatorCount}</li>`;
    statsHtml += `<li class="mt-1 pt-1 border-t border-[var(--ui-border-color)] border-opacity-30"><strong>BN Preds (at run start):</strong>`;
    if (statDetails.bnPredictionsAtRunStart) {
        const {
            extinction: extP,
            growth: growthP,
            starvationRisk: starvP
        } = statDetails.bnPredictionsAtRunStart;
        statsHtml += `<ul class="list-disc ml-5 text-xs">`;
        statsHtml += `<li>Ext: P ${extP?.prey?.toFixed(3) ?? 'N/A'}, R ${extP?.predator?.toFixed(3) ?? 'N/A'} ${extP?.error ? '(' + extP.error.substring(0, 10) + '..)' : ''}</li>`;
        statsHtml += `<li>Grow: Pl ${growthP?.plant?.toFixed(3) ?? 'N/A'}, P ${growthP?.prey?.toFixed(3) ?? 'N/A'}, R ${growthP?.predator?.toFixed(3) ?? 'N/A'} ${growthP?.error ? '(' + growthP.error.substring(0, 10) + '..)' : ''}</li>`;
        statsHtml += `<li>StarvRisk: P ${starvP?.prey?.toFixed(3) ?? 'N/A'}, R ${starvP?.predator?.toFixed(3) ?? 'N/A'} ${starvP?.error ? '(' + starvP.error.substring(0, 10) + '..)' : ''}</li>`;
        statsHtml += `</ul></li>`;
    } else statsHtml += ` N/A</li>`;
    if (runData.bnPredictionError !== undefined) {
        statsHtml += `<li><strong>BN Prediction Error:</strong> ${runData.bnPredictionError.toFixed(3)}</li>`;
    }
    const duration = runData.durationFrames > 0 ? runData.durationFrames : 1;
    const plantBirthRate = statDetails.totalPlantBirths / duration;
    const plantConsumptionRate = statDetails.totalPlantsConsumed / duration;
    const preyBirthRate = statDetails.totalPreyBirths / duration;
    const preyDeathRateTotal = (statDetails.totalPreyDeathsByPredation + statDetails.totalPreyDeathsByStarvation) / duration;
    const predBirthRate = statDetails.totalPredatorBirths / duration;
    const predDeathRateTotal = (statDetails.totalPredatorDeathsByStarvation + statDetails.totalPredatorDeathsByMobbing) / duration;
    statsHtml += `<li class="mt-1 pt-1 border-t border-[var(--ui-border-color)] border-opacity-30"><strong>Actual Growth Outcome (per frame):</strong><ul class="list-disc ml-5 text-xs">`;
    statsHtml += `<li>Plant: ${plantBirthRate > plantConsumptionRate ? 'Achieved' : 'Not Achieved'} (B:${plantBirthRate.toFixed(3)}, C:${plantConsumptionRate.toFixed(3)})</li>`;
    statsHtml += `<li>Prey: ${preyBirthRate > preyDeathRateTotal ? 'Achieved' : 'Not Achieved'} (B:${preyBirthRate.toFixed(3)}, D:${preyDeathRateTotal.toFixed(3)})</li>`;
    statsHtml += `<li>Predator: ${predBirthRate > predDeathRateTotal ? 'Achieved' : 'Not Achieved'} (B:${predBirthRate.toFixed(3)}, D:${predDeathRateTotal.toFixed(3)})</li></ul></li>`;
    statsHtml += '</ul>';
    
    DOM_ELEMENTS.pastRunStatsDisplay.innerHTML = statsHtml;
    setTimeout(() => {
        if (!pastPopulationGraphCanvas || !pastCumulativeGraphCanvas || !pastBNPredictionGraphCanvas) return;
        [pastPopulationGraphCanvas, pastCumulativeGraphCanvas, pastBNPredictionGraphCanvas,
         pastBNPredictionExtinctionGraphCanvas, pastBNPredictionGrowthGraphCanvas,
         pastBNPredictionStarvationGraphCanvas].forEach(c => {
            c.width = c.clientWidth;
            c.height = c.clientHeight || 200;
        });
        const popHistories = [{
            data: runData.populationGraphHistory.plants,
            color: getComputedCssVar(CSS_VARS.PLANT_COLOR),
            lineWidth: 2,
            label: "Plants"
        }, {
            data: runData.populationGraphHistory.prey,
            color: getComputedCssVar(CSS_VARS.PREY_COLOR),
            lineWidth: 2,
            label: "Prey"
        }, {
            data: runData.populationGraphHistory.predators,
            color: getComputedCssVar(CSS_VARS.PREDATOR_COLOR),
            lineWidth: 2,
            label: "Predators"
        }, {
            data: runData.populationGraphHistory.preyPredationDeaths,
            color: getComputedCssVar(CSS_VARS.GRAPH_PREY_PRED_DEATH_COLOR),
            lineWidth: 1.5,
            label: "Prey (PredD)"
        }, {
            data: runData.populationGraphHistory.preyStarvationDeaths,
            color: getComputedCssVar(CSS_VARS.GRAPH_PREY_STARV_DEATH_COLOR),
            lineWidth: 1.5,
            label: "Prey (StarvD)"
        }, {
            data: runData.populationGraphHistory.predatorStarvationDeaths,
            color: getComputedCssVar(CSS_VARS.GRAPH_PRED_STARV_DEATH_COLOR),
            lineWidth: 1.5,
            label: "Pred (StarvD)"
        }, {
            data: runData.populationGraphHistory.predatorMobbingDeaths,
            color: getComputedCssVar(CSS_VARS.GRAPH_PRED_MOB_DEATH_COLOR),
            lineWidth: 1.5,
            label: "Pred (MobD)"
        }];
        drawGenericGraph(pastPopulationGraphCtx, pastPopulationGraphCanvas, popHistories, runData.populationGraphHistory.maxLength);
        populateGraphLegend('pastPopulationGraphLegend', popHistories);
        const cumHistories = [{
                data: runData.cumulativeGraphHistory.plantBirths || [],
                color: getComputedCssVar(CSS_VARS.GRAPH_PLANT_BIRTH_COLOR),
                lineWidth: 2,
                label: "Plant Births"
            },
            {
                data: runData.cumulativeGraphHistory.plantsConsumed || [],
                color: getComputedCssVar(CSS_VARS.GRAPH_PLANTS_CONSUMED_COLOR),
                lineWidth: 2,
                label: "Plants Consumed"
            },
            {
                data: runData.cumulativeGraphHistory.preyBirths || [],
                color: getComputedCssVar(CSS_VARS.GRAPH_PREY_BIRTH_COLOR),
                lineWidth: 2,
                label: "Prey Births"
            },
            {
                data: runData.cumulativeGraphHistory.predatorBirths || [],
                color: getComputedCssVar(CSS_VARS.GRAPH_PREDATOR_BIRTH_COLOR),
                lineWidth: 2,
                label: "Predator Births"
            },
            {
                data: runData.cumulativeGraphHistory.totalPreyDeaths || [],
                color: getComputedCssVar(CSS_VARS.GRAPH_TOTAL_PREY_DEATH_COLOR),
                lineWidth: 2,
                label: "Total Prey Deaths"
            },
            {
                data: runData.cumulativeGraphHistory.totalPredatorDeaths || [],
                color: getComputedCssVar(CSS_VARS.GRAPH_TOTAL_PREDATOR_DEATH_COLOR),
                lineWidth: 2,
                label: "Total Predator Deaths"
            }
        ];
        drawGenericGraph(pastCumulativeGraphCtx, pastCumulativeGraphCanvas, cumHistories, runData.cumulativeGraphHistory.maxLength);
        populateGraphLegend('pastCumulativeGraphLegend', cumHistories);

        const bnHistories = [
            { data: runData.bnPredictionGraphHistory.plantExtinctionProb || [], color: getComputedCssVar(CSS_VARS.PLANT_COLOR), lineWidth: 1.5, label: "P(Plant Extinct)" },
            { data: runData.bnPredictionGraphHistory.preyExtinctionProb || [], color: getComputedCssVar(CSS_VARS.PREY_COLOR), lineWidth: 1.5, label: "P(Prey Extinct)" },
            { data: runData.bnPredictionGraphHistory.predatorExtinctionProb || [], color: getComputedCssVar(CSS_VARS.PREDATOR_COLOR), lineWidth: 1.5, label: "P(Pred Extinct)" },
            { data: runData.bnPredictionGraphHistory.favorableGrowthPlantProb || [], color: modifyHslColor(getComputedCssVar(CSS_VARS.PLANT_COLOR), 1, 1.2), lineWidth: 1.5, label: "P(Plant Growth)" },
            { data: runData.bnPredictionGraphHistory.favorableGrowthPreyProb || [], color: modifyHslColor(getComputedCssVar(CSS_VARS.PREY_COLOR), 1, 1.2), lineWidth: 1.5, label: "P(Prey Growth)" },
            { data: runData.bnPredictionGraphHistory.favorableGrowthPredatorProb || [], color: modifyHslColor(getComputedCssVar(CSS_VARS.PREDATOR_COLOR), 1, 1.2), lineWidth: 1.5, label: "P(Pred Growth)" },
            { data: runData.bnPredictionGraphHistory.preyStarvationRiskProb || [], color: modifyHslColor(getComputedCssVar(CSS_VARS.PREY_COLOR), 0.8, 0.8), lineWidth: 1.5, label: "P(Prey Starv. Risk)" },
            { data: runData.bnPredictionGraphHistory.predatorStarvationRiskProb || [], color: modifyHslColor(getComputedCssVar(CSS_VARS.PREDATOR_COLOR), 0.8, 0.8), lineWidth: 1.5, label: "P(Pred Starv. Risk)" }
        ];
        drawGenericGraph(pastBNPredictionGraphCtx, pastBNPredictionGraphCanvas, bnHistories, runData.bnPredictionGraphHistory.maxLength, 1.05, true);
        populateGraphLegend('pastBNPredictionGraphLegend', bnHistories);

        const bnExtHistories = [bnHistories[0], bnHistories[1], bnHistories[2]];
        drawGenericGraph(pastBNPredictionExtinctionGraphCtx, pastBNPredictionExtinctionGraphCanvas, bnExtHistories, runData.bnPredictionGraphHistory.maxLength, 1.05, true);
        populateGraphLegend('pastBNPredictionExtinctionGraphLegend', bnExtHistories);

        const bnGrowthHistories = [bnHistories[3], bnHistories[4], bnHistories[5]];
        drawGenericGraph(pastBNPredictionGrowthGraphCtx, pastBNPredictionGrowthGraphCanvas, bnGrowthHistories, runData.bnPredictionGraphHistory.maxLength, 1.05, true);
        populateGraphLegend('pastBNPredictionGrowthGraphLegend', bnGrowthHistories);

        const bnStarvHistories = [bnHistories[6], bnHistories[7]];
        drawGenericGraph(pastBNPredictionStarvationGraphCtx, pastBNPredictionStarvationGraphCanvas, bnStarvHistories, runData.bnPredictionGraphHistory.maxLength, 1.05, true);
        populateGraphLegend('pastBNPredictionStarvationGraphLegend', bnStarvHistories);
    }, 50);
}

    function resetSimulation() {
      plants = []; prey = []; predators = []; entities = [];
      Object.keys(populationHistory).forEach(key => { if (key !== 'maxLength') populationHistory[key] = []; });
      Object.keys(cumulativeHistory).forEach(key => { if (key !== 'maxLength') cumulativeHistory[key] = []; });
      Object.keys(bnPredictionHistory).forEach(key => { // Clear BN prediction history
        if (key !== 'maxLength') bnPredictionHistory[key] = [];
      });
      bnPredictionErrorHistory.errors = [];
      totalPlantBirths = 0; totalPlantsConsumed = 0;
      totalPreyDeathsByPredation = 0; totalPreyDeathsByStarvation = 0;
      totalPredatorDeathsByStarvation = 0; totalPredatorDeathsByMobbing = 0;
      totalPreyBirths = 0; totalPredatorBirths = 0;
      intervalPreyPredDeaths = 0; intervalPreyStarvDeaths = 0;
      intervalPredStarvDeaths = 0; intervalPredMobDeaths = 0;
      historyUpdateCounter = 0;
      simulationTimeAccumulator = 0;

      config.preyVisionRadiusSq = config.preyVisionRadius * config.preyVisionRadius;
      config.predatorVisionRadiusSq = config.predatorVisionRadius * config.predatorVisionRadius;

      // for (let i = 0; i < config.initialPlants; i++) plants.push(new Plant(random(0, canvas.width), random(0, canvas.height)));
      // --- Modified Initial Plant Placement ---
      let placedPlantsCount = 0;
      const tempPlantForRadius = new Plant(0, 0); // Create once to get radius for calculations
      const newPlantRadius = tempPlantForRadius.radius; // Assuming all plants have the same initial radius

      for (let i = 0; i < config.initialPlants; i++) {
        let spot = null;
        let placementAttempts = 0;
        const MAX_INITIAL_PLACEMENT_ATTEMPTS = 100; // Increased attempts for initial placement

        while (!spot && placementAttempts < MAX_INITIAL_PLACEMENT_ATTEMPTS) {
          const candidateX = random(newPlantRadius, canvas.width - newPlantRadius);
          const candidateY = random(newPlantRadius, canvas.height - newPlantRadius);
          let overlaps = false;
          for (const p of plants) { // Check against already placed plants
            if (distanceSq(candidateX, candidateY, p.pos.x, p.pos.y) < (newPlantRadius + p.radius + config.plantSpawnSeparationMargin) ** 2) {
              overlaps = true;
              break;
            }
          }
          if (!overlaps) {
            spot = { x: candidateX, y: candidateY };
          }
          placementAttempts++;
        }

        if (spot) {
          plants.push(new Plant(spot.x, spot.y));
          placedPlantsCount++;
        } else {
          // console.warn(`Could not place initial plant ${i+1} with sufficient separation after ${MAX_INITIAL_PLACEMENT_ATTEMPTS} attempts. Target: ${config.initialPlants}, Placed: ${placedPlantsCount}`);
          // Optionally, if it's too hard to place (e.g. canvas too small for requested plants with separation)
          if (placedPlantsCount < config.initialPlants / 2 && i > config.initialPlants / 3) {
            console.warn("Giving up on placing more initial plants due to density or small canvas size relative to separation needs.");
            break;
          }
        }
      }
      if (placedPlantsCount < config.initialPlants) {
        // console.log(`Successfully placed ${placedPlantsCount} out of ${config.initialPlants} requested initial plants with separation.`);
      }
      for (let i = 0; i < config.initialPrey; i++) prey.push(new Prey(random(0, canvas.width), random(0, canvas.height)));
      for (let i = 0; i < config.initialPredators; i++) predators.push(new Predator(random(0, canvas.width), random(0, canvas.height)));
    }

    function updateEntities() {
      plants = plants.filter(p => p.update());
      if (plants.length === 0 && config.initialPlants > 0 && currentRunDeathFrames.plant === null) {
        currentRunDeathFrames.plant = currentRunFrameCounter;
      }

      const newPrey = [];
      for (const p of prey) {
        if (p.update()) {
          newPrey.push(p);
        } else {
          if (p.causeOfDeath === 'predation') { totalPreyDeathsByPredation++; intervalPreyPredDeaths++; }
          else if (p.causeOfDeath === 'starvation') { totalPreyDeathsByStarvation++; intervalPreyStarvDeaths++; }
        }
      }
      prey = newPrey;
      if (prey.length === 0 && config.initialPrey > 0 && currentRunDeathFrames.prey === null) {
        currentRunDeathFrames.prey = currentRunFrameCounter;
      }

      const newPredators = [];
      for (const p of predators) {
        if (p.update()) {
          newPredators.push(p);
        } else {
          if (p.causeOfDeath === 'starvation') { totalPredatorDeathsByStarvation++; intervalPredStarvDeaths++; }
          else if (p.causeOfDeath === 'mobbing') { totalPredatorDeathsByMobbing++; intervalPredMobDeaths++; }
        }
      }
      predators = newPredators;
      if (predators.length === 0 && config.initialPredators > 0 && currentRunDeathFrames.predator === null) {
        currentRunDeathFrames.predator = currentRunFrameCounter;
      }

      entities = [...plants, ...prey, ...predators];
      if (entities.length > config.maxEntities) {
        let toRemoveCount = entities.length - config.maxEntities;
        const cull = (arr, minKeep) => {
          if (toRemoveCount <= 0 || arr.length <= minKeep) return arr;
          const numToRemoveFromArray = Math.min(toRemoveCount, arr.length - minKeep);
          // Make entities that are culled due to overpopulation animate their death
          for (let i = 0; i < numToRemoveFromArray; i++) {
            if (arr[i].animationState === 'alive') { // Only force death if currently alive
              arr[i].animationState = 'dying';
              arr[i].deathAnimTimer = config.deathAnimationDuration / 2; // Faster death for culling
              arr[i].isEffectivelyDead = true;
              arr[i].causeOfDeath = 'overpopulation'; // Or some other generic cause
            }
          }
          // The actual removal will happen in the next frame's filter when animationState is 'dead'
          // For now, we just mark them. The actual number removed from array immediately might be less.
          // This culling approach needs to be careful not to break the animation system.
          // A simpler immediate culling:
          const culledArr = arr.slice(numToRemoveFromArray);
          toRemoveCount -= (arr.length - culledArr.length);
          return culledArr; // This removes them immediately, skipping death animation for culled ones.
        };
        // For simplicity, immediate culling is kept. To animate, culling would mark for death.
        plants = cull(plants, 10);
        prey = cull(prey, 5);
        predators = cull(predators, 1);
        entities = [...plants, ...prey, ...predators];
      }

      DOM_ELEMENTS.plantBirthsDisplay.textContent = totalPlantBirths;
      DOM_ELEMENTS.plantsConsumedDisplay.textContent = totalPlantsConsumed;
      DOM_ELEMENTS.plantCount.textContent = plants.length;
      DOM_ELEMENTS.preyCount.textContent = prey.length;
      DOM_ELEMENTS.predatorCount.textContent = predators.length;
      DOM_ELEMENTS.totalEntities.textContent = entities.length;
      DOM_ELEMENTS.preyPredationDeathsDisplay.textContent = totalPreyDeathsByPredation;
      DOM_ELEMENTS.preyStarvationDeathsDisplay.textContent = totalPreyDeathsByStarvation;
      DOM_ELEMENTS.predatorStarvationDeathsDisplay.textContent = totalPredatorDeathsByStarvation;
      DOM_ELEMENTS.predatorMobbingDeathsDisplay.textContent = totalPredatorDeathsByMobbing;
      DOM_ELEMENTS.preyBirthsDisplay.textContent = totalPreyBirths;
      DOM_ELEMENTS.predatorBirthsDisplay.textContent = totalPredatorBirths;
      DOM_ELEMENTS.totalPreyDeathsDisplay.textContent = totalPreyDeathsByPredation + totalPreyDeathsByStarvation;
      DOM_ELEMENTS.totalPredatorDeathsDisplay.textContent = totalPredatorDeathsByStarvation + totalPredatorDeathsByMobbing;
    }

    function updateGraphHistories() {
      historyUpdateCounter++;
      if (historyUpdateCounter >= historyUpdateInterval) {
        historyUpdateCounter = 0;
        populationHistory.plants.push(plants.length);
        populationHistory.prey.push(prey.length);
        populationHistory.predators.push(predators.length);
        populationHistory.preyPredationDeaths.push(intervalPreyPredDeaths);
        populationHistory.preyStarvationDeaths.push(intervalPreyStarvDeaths);
        populationHistory.predatorStarvationDeaths.push(intervalPredStarvDeaths);
        populationHistory.predatorMobbingDeaths.push(intervalPredMobDeaths);
        intervalPreyPredDeaths = 0; intervalPreyStarvDeaths = 0;
        intervalPredStarvDeaths = 0; intervalPredMobDeaths = 0;
        Object.values(populationHistory).forEach(arr => { if (Array.isArray(arr) && arr.length > populationHistory.maxLength) arr.shift(); });

        cumulativeHistory.plantBirths.push(totalPlantBirths);
        cumulativeHistory.plantsConsumed.push(totalPlantsConsumed);
        cumulativeHistory.preyBirths.push(totalPreyBirths);
        cumulativeHistory.predatorBirths.push(totalPredatorBirths);
        cumulativeHistory.totalPreyDeaths.push(totalPreyDeathsByPredation + totalPreyDeathsByStarvation);
        cumulativeHistory.totalPredatorDeaths.push(totalPredatorDeathsByStarvation + totalPredatorDeathsByMobbing);
        Object.values(cumulativeHistory).forEach(arr => { if (Array.isArray(arr) && arr.length > cumulativeHistory.maxLength) arr.shift(); });
      }
    }

    function drawSimplifiedGenericGraph(graphCtxLocal, canvasLocal, histories, maxLength) {
      if (!canvasLocal || canvasLocal.width === 0 || canvasLocal.height === 0) return;
      const bgColor = getComputedCssVar(CSS_VARS.BG_COLOR);
      graphCtxLocal.fillStyle = bgColor;
      graphCtxLocal.fillRect(0, 0, canvasLocal.width, canvasLocal.height);

      let maxVal = 1;
      histories.forEach(h => { if (h.data) h.data.forEach(val => { if (val > maxVal) maxVal = val; }) });
      if (maxVal < 10) maxVal = 10;

      const padding = 3;
      const chartWidth = canvasLocal.width - 2 * padding;
      const chartHeight = canvasLocal.height - 2 * padding;

      if (chartWidth <= 0 || chartHeight <= 0) return;

      const xStep = chartWidth / Math.max(1, maxLength - 1);

      histories.forEach(h => {
        if (!h.data || h.data.length < 2) return;
        graphCtxLocal.beginPath();
        graphCtxLocal.strokeStyle = h.color;
        graphCtxLocal.lineWidth = h.lineWidth || 1.5;
        h.data.forEach((val, index) => {
          const x = padding + index * xStep;
          const y = padding + chartHeight - (val / maxVal) * chartHeight;
          if (index === 0) graphCtxLocal.moveTo(x, y);
          else graphCtxLocal.lineTo(x, y);
        });
        graphCtxLocal.stroke();
      });
    }

    function drawGenericGraph(graphCtxLocal, canvasLocal, histories, maxLength) {
      if (!canvasLocal || canvasLocal.width === 0 || canvasLocal.height === 0) return;

      const bgColor = getComputedCssVar(CSS_VARS.BG_COLOR);
      const gridColor = getComputedCssVar(CSS_VARS.GRAPH_GRID_COLOR);
      const textColor = getComputedCssVar(CSS_VARS.TEXT_COLOR_DARKER);

      graphCtxLocal.fillStyle = bgColor;
      graphCtxLocal.fillRect(0, 0, canvasLocal.width, canvasLocal.height);

      let maxVal = 10;
      histories.forEach(h => { if (h.data) h.data.forEach(val => { if (val > maxVal) maxVal = val; }) });
      maxVal = Math.ceil(maxVal / 10) * 10;
      if (maxVal === 0) maxVal = 10;

      const padding = { top: 20, right: 20, bottom: 30, left: 30 };
      const chartWidth = canvasLocal.width - padding.left - padding.right;
      const chartHeight = canvasLocal.height - padding.top - padding.bottom;

      if (chartWidth <= 0 || chartHeight <= 0) return;

      graphCtxLocal.strokeStyle = gridColor;
      graphCtxLocal.lineWidth = 0.5;
      graphCtxLocal.font = '10px Inter, sans-serif';
      graphCtxLocal.fillStyle = textColor;
      graphCtxLocal.textAlign = 'right';
      graphCtxLocal.textBaseline = 'middle';

      const numYGridLines = 5;
      for (let i = 0; i <= numYGridLines; i++) {
        const y = padding.top + (chartHeight / numYGridLines) * i;
        graphCtxLocal.beginPath();
        graphCtxLocal.moveTo(padding.left, y);
        graphCtxLocal.lineTo(padding.left + chartWidth, y);
        graphCtxLocal.stroke();
        graphCtxLocal.fillText(Math.round(maxVal * (1 - i / numYGridLines)), padding.left - 5, y);
      }

      graphCtxLocal.textAlign = 'center';
      graphCtxLocal.textBaseline = 'top';
      const numXLabels = 4;
      for (let i = 0; i <= numXLabels; i++) {
        const x = padding.left + (chartWidth / numXLabels) * i;
        graphCtxLocal.beginPath();
        graphCtxLocal.moveTo(x, padding.top);
        graphCtxLocal.lineTo(x, padding.top + chartHeight);
        graphCtxLocal.stroke();

        if (i === 0 || i === numXLabels || i === Math.floor(numXLabels / 2) || numXLabels <= 4) {
          const frameLabel = Math.round((maxLength / numXLabels) * i * historyUpdateInterval);
          graphCtxLocal.fillText(frameLabel, x, padding.top + chartHeight + 5);
        }
      }

      const xStep = chartWidth / Math.max(1, maxLength - 1);
      histories.forEach(h => {
        if (!h.data || h.data.length < 2) return;
        graphCtxLocal.beginPath();
        graphCtxLocal.strokeStyle = h.color;
        graphCtxLocal.lineWidth = h.lineWidth || 2;
        h.data.forEach((val, index) => {
          const x = padding.left + index * xStep;
          const y = padding.top + chartHeight - (val / maxVal) * chartHeight;
          if (index === 0) graphCtxLocal.moveTo(x, y);
          else graphCtxLocal.lineTo(x, y);
        });
        graphCtxLocal.stroke();
      });
    }

    function drawPopulationGraph() {
      const histories = [
        { data: populationHistory.plants, color: getComputedCssVar(CSS_VARS.PLANT_COLOR), lineWidth: 2, label: "Plants", visible: true },
        { data: populationHistory.prey, color: getComputedCssVar(CSS_VARS.PREY_COLOR), lineWidth: 2, label: "Prey", visible: true },
        { data: populationHistory.predators, color: getComputedCssVar(CSS_VARS.PREDATOR_COLOR), lineWidth: 2, label: "Predators", visible: true },
        { data: populationHistory.preyPredationDeaths, color: getComputedCssVar(CSS_VARS.GRAPH_PREY_PRED_DEATH_COLOR), lineWidth: 1.5, label: "Prey (PredD)", visible: true },
        { data: populationHistory.preyStarvationDeaths, color: getComputedCssVar(CSS_VARS.GRAPH_PREY_STARV_DEATH_COLOR), lineWidth: 1.5, label: "Prey (StarvD)", visible: true },
        { data: populationHistory.predatorStarvationDeaths, color: getComputedCssVar(CSS_VARS.GRAPH_PRED_STARV_DEATH_COLOR), lineWidth: 1.5, label: "Pred (StarvD)", visible: true },
        { data: populationHistory.predatorMobbingDeaths, color: getComputedCssVar(CSS_VARS.GRAPH_PRED_MOB_DEATH_COLOR), lineWidth: 1.5, label: "Pred (MobD)", visible: true }
      ];
      drawGenericGraph(populationGraphCtx, populationGraphCanvas, histories, populationHistory.maxLength);
      if (DOM_ELEMENTS.currentPopulationGraphLegend) {
        populateGraphLegend('currentPopulationGraphLegend', histories, drawPopulationGraph);
      }
    }

    function drawCumulativeGraph() {
      const histories = [
        { data: cumulativeHistory.plantBirths, color: getComputedCssVar(CSS_VARS.GRAPH_PLANT_BIRTH_COLOR), lineWidth: 2, label: "Plant Births", visible: true },
        { data: cumulativeHistory.plantsConsumed, color: getComputedCssVar(CSS_VARS.GRAPH_PLANTS_CONSUMED_COLOR), lineWidth: 2, label: "Plants Consumed", visible: true },
        { data: cumulativeHistory.preyBirths, color: getComputedCssVar(CSS_VARS.GRAPH_PREY_BIRTH_COLOR), lineWidth: 2, label: "Prey Births", visible: true },
        { data: cumulativeHistory.predatorBirths, color: getComputedCssVar(CSS_VARS.GRAPH_PREDATOR_BIRTH_COLOR), lineWidth: 2, label: "Predator Births", visible: true },
        { data: cumulativeHistory.totalPreyDeaths, color: getComputedCssVar(CSS_VARS.GRAPH_TOTAL_PREY_DEATH_COLOR), lineWidth: 2, label: "Total Prey Deaths", visible: true },
        { data: cumulativeHistory.totalPredatorDeaths, color: getComputedCssVar(CSS_VARS.GRAPH_TOTAL_PREDATOR_DEATH_COLOR), lineWidth: 2, label: "Total Predator Deaths", visible: true }
      ];
      drawGenericGraph(cumulativeGraphCtx, cumulativeGraphCanvas, histories, cumulativeHistory.maxLength, null, false, true, true);
      if (DOM_ELEMENTS.currentCumulativeGraphLegend) {
        populateGraphLegend('currentCumulativeGraphLegend', histories, drawCumulativeGraph);
      }
    }

    function render() {
      ctx.fillStyle = getComputedCssVar(CSS_VARS.BG_COLOR);
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      plants.forEach(p => p.draw());
      prey.forEach(p => p.draw());
      predators.forEach(p => p.draw());

      if (config.showTargetLines) {
        ctx.save();
        ctx.lineWidth = 0.75;
        const drawTargetLineForEntity = (entity) => {
          if (entity.target && entity.animationState !== 'dying' && entity.animationState !== 'dead' &&
            (entities.includes(entity.target) || plants.includes(entity.target))) {
            if (entity.target.animationState !== 'dying' && entity.target.animationState !== 'dead') {
              ctx.beginPath();
              ctx.moveTo(entity.pos.x, entity.pos.y);
              ctx.lineTo(entity.target.pos.x, entity.target.pos.y);
              if (entity.target instanceof Plant) ctx.strokeStyle = 'hsla(120, 70%, 50%, 0.2)';
              else if (entity.target instanceof Prey) ctx.strokeStyle = 'hsla(60, 70%, 60%, 0.2)';
              else if (entity.target instanceof Predator) ctx.strokeStyle = 'hsla(0, 70%, 60%, 0.25)';
              else ctx.strokeStyle = 'hsla(0, 0%, 100%, 0.15)';
              ctx.stroke();
            }
          }
        };
        prey.forEach(drawTargetLineForEntity);
        predators.forEach(drawTargetLineForEntity);
        ctx.restore();
      }

      if (DOM_ELEMENTS.statsOverlay.classList.contains('visible')) {
        drawPopulationGraph();
        drawCumulativeGraph();
      }
    }

        function gameLoop(timestamp) {
      if (!simulationIsActive) { gameLoopRunning = false; return; }
      gameLoopRunning = true;
      animationFrameId = requestAnimationFrame(gameLoop);

      const deltaTime = (timestamp - lastTimestamp) / 1000;
      lastTimestamp = timestamp;

      if (deltaTime > 0) {
        fpsHistory.push(1 / deltaTime);
        if (fpsHistory.length > fpsHistoryLength) fpsHistory.shift();
        fps = fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length;
        DOM_ELEMENTS.fpsDisplay.textContent = Math.round(fps);
      }

      const clampedDeltaTime = Math.min(deltaTime, 0.2);
      simulationTimeAccumulator += clampedDeltaTime * config.simulationSpeedMultiplier;

      let simStepsThisFrame = 0;
      while (simulationTimeAccumulator >= SIMULATION_FIXED_STEP && simStepsThisFrame < MAX_SIMULATION_STEPS_PER_FRAME) {
        currentRunFrameCounter++;
        updateEntities();
        updateGraphHistories(); 

        bnUpdateCounter++;
        if (bnUpdateCounter >= bnUpdateInterval) {
            bnUpdateCounter = 0;

            const paramsForLiveGraph = structuredClone(config); // Start with UI params
            paramsForLiveGraph.initialPlants = Math.max(0, plants.length); // Use live counts
            paramsForLiveGraph.initialPrey = Math.max(0, prey.length);
            paramsForLiveGraph.initialPredators = Math.max(0, predators.length);

            const extPredsHist = predictExtinctionProbabilities(paramsForLiveGraph);
            const growthPredsHist = predictFavorableGrowth(paramsForLiveGraph);
            const starvPredsHist = predictStarvationRiskProbabilities(paramsForLiveGraph);

            if (!extPredsHist.error) {
                bnPredictionHistory.plantExtinctionProb.push(extPredsHist.plant);
                bnPredictionHistory.preyExtinctionProb.push(extPredsHist.prey);
                bnPredictionHistory.predatorExtinctionProb.push(extPredsHist.predator);
            } else {
                bnPredictionHistory.plantExtinctionProb.push(0.5);
                bnPredictionHistory.preyExtinctionProb.push(0.5);
                bnPredictionHistory.predatorExtinctionProb.push(0.5);
            }
            if (!growthPredsHist.error) {
                bnPredictionHistory.favorableGrowthPlantProb.push(growthPredsHist.plant);
                bnPredictionHistory.favorableGrowthPreyProb.push(growthPredsHist.prey);
                bnPredictionHistory.favorableGrowthPredatorProb.push(growthPredsHist.predator);
            } else {
                bnPredictionHistory.favorableGrowthPlantProb.push(0.5);
                bnPredictionHistory.favorableGrowthPreyProb.push(0.5);
                bnPredictionHistory.favorableGrowthPredatorProb.push(0.5);
            }
            if (!starvPredsHist.error) {
                bnPredictionHistory.preyStarvationRiskProb.push(starvPredsHist.prey);
                bnPredictionHistory.predatorStarvationRiskProb.push(starvPredsHist.predator);
            } else {
                bnPredictionHistory.preyStarvationRiskProb.push(0.5);
                bnPredictionHistory.predatorStarvationRiskProb.push(0.5);
            }

            Object.values(bnPredictionHistory).forEach(arr => {
                if (Array.isArray(arr) && arr.length > bnPredictionHistory.maxLength) arr.shift();
            });

            if (DOM_ELEMENTS.statsOverlay.classList.contains('visible')) {
                updateCurrentBNPredictionsDisplay();
                drawBNPredictionGraph();
                drawBNPredictionExtinctionGraph();
                drawBNPredictionGrowthGraph();
                drawBNPredictionStarvationGraph();
            }
        }

        let deadPopulations = 0, minFramesForGameOver = 100;
        if (config.initialPlants > 0 && plants.length === 0) deadPopulations++;
        if (config.initialPrey > 0 && prey.length === 0) deadPopulations++;
        if (config.initialPredators > 0 && predators.length === 0) deadPopulations++;

        let initialDiversity = (config.initialPlants > 0 ? 1 : 0) + (config.initialPrey > 0 ? 1 : 0) + (config.initialPredators > 0 ? 1 : 0);
        if (initialDiversity <= 1) minFramesForGameOver = 50;

        if (deadPopulations >= Math.max(1, initialDiversity - 1) && currentRunFrameCounter > minFramesForGameOver && initialDiversity > 0) {
          console.log(`Run ${currentRunNumber} ended naturally after ${currentRunFrameCounter} simulation steps.`);
          const nextParams = suggestNextParameters();
          if (nextParams) startNewRun(nextParams);
          else {
            const currentConfigSnapshot = structuredClone(config);
            let bnExtPreds = null, bnGrowthPreds = null, bnStarvPreds = null;
            // For bnPredictionsForNextRun, we use the pure UI config, NOT live populations
            if (isBNReady()) {
              bnExtPreds = predictExtinctionProbabilities(currentConfigSnapshot);
              bnGrowthPreds = predictFavorableGrowth(currentConfigSnapshot);
              bnStarvPreds = predictStarvationRiskProbabilities(currentConfigSnapshot);
            }
            bnPredictionsForNextRun = { extinction: bnExtPreds, growth: bnGrowthPreds, starvationRisk: bnStarvPreds };
            startNewRun(currentConfigSnapshot);
          }
          return;
        }
        simulationTimeAccumulator -= SIMULATION_FIXED_STEP;
        simStepsThisFrame++;
      }

      render();
    }
function wrapAndDrawText(ctxLocal, text, x, y, maxWidth, baseFontSize, detailFontSize, detailOffsetY, detailText) {
  let words = text.split(' ');
  let line = '';
  let lines = [];
  let currentFontSize = baseFontSize;
  const MIN_FONT_SIZE = Math.max(8, detailFontSize - 1);
  function testLineWidth(str, fontStr) {
    const original = ctxLocal.font;
    ctxLocal.font = fontStr;
    const width = ctxLocal.measureText(str).width;
    ctxLocal.font = original;
    return width;
  }
  let attempt = 0;
  let fontString = `bold ${currentFontSize}px 'Inter', sans-serif`;
  while (testLineWidth(text, fontString) > maxWidth && currentFontSize > MIN_FONT_SIZE && attempt < 5) {
    currentFontSize -= 0.5;
    fontString = `bold ${currentFontSize}px 'Inter', sans-serif`;
    attempt++;
  }
  ctxLocal.font = fontString;
  if (ctxLocal.measureText(text).width <= maxWidth) {
    lines.push(text);
  } else {
    let splitPoint = -1;
    const camelCase = text.match(/[a-z][A-Z]/);
    if (camelCase && camelCase.index > 0) splitPoint = camelCase.index + 1;
    else if (text.includes('Growth')) splitPoint = text.indexOf('Growth');
    else if (text.includes('Cooldown')) splitPoint = text.indexOf('Cooldown');
    else if (text.includes('Reproduction')) splitPoint = text.indexOf('Reproduction');
    else if (text.includes('Ratio')) {
      splitPoint = text.indexOf('Ratio') > 0 ? text.indexOf('Ratio') : (text.indexOf('To') > 0 ? text.indexOf('To') : -1);
    }
    if (splitPoint !== -1) {
      const l1 = text.substring(0, splitPoint);
      const l2 = text.substring(splitPoint);
      if (ctxLocal.measureText(l1).width <= maxWidth && ctxLocal.measureText(l2).width <= maxWidth) {
        lines.push(l1);
        lines.push(l2);
      }
    }
    if (lines.length === 0) {
      for (let n = 0; n < words.length; n++) {
        let testContent = line + words[n] + ' ';
        if (ctxLocal.measureText(testContent).width > maxWidth && n > 0) {
          lines.push(line.trim());
          line = words[n] + ' ';
        } else {
          line = testContent;
        }
      }
      lines.push(line.trim());
    }
  }
  lines = lines.map(l => {
    if (ctxLocal.measureText(l).width > maxWidth) {
      let truncated = l;
      while (ctxLocal.measureText(truncated + '...').width > maxWidth && truncated.length > 3) {
        truncated = truncated.slice(0, -1);
      }
      return truncated + '...';
    }
    return l;
  });
  if (lines.length > 2) lines = lines.slice(0, 2);
  const lineHeight = currentFontSize * 1.1;
  let startY = y - ((lines.length - 1) * lineHeight / 2) - (detailText ? detailFontSize / 3 : 0);
  ctxLocal.fillStyle = getComputedCssVar(CSS_VARS.TEXT_COLOR);
  ctxLocal.font = fontString;
  lines.forEach((l, i) => ctxLocal.fillText(l, x, startY + i * lineHeight));
  if (detailText) {
    ctxLocal.font = `${detailFontSize}px 'Inter', sans-serif`;
    if (ctxLocal.measureText(detailText).width > maxWidth) {
      let truncatedDetail = detailText;
      while (ctxLocal.measureText(truncatedDetail + '...').width > maxWidth && truncatedDetail.length > 3) {
        truncatedDetail = truncatedDetail.slice(0, -1);
      }
      detailText = truncatedDetail + '...';
    }
    ctxLocal.fillText(detailText, x, y + detailOffsetY);
  }
}
      function drawBayesianNetworkVisualization() {
        if (!simBayesianNetwork || !bnVisualizationCanvas) return;
        const canvasEl = bnVisualizationCanvas, ctxLocal = bnVisualizationCtx;
        canvasEl.width = canvasEl.clientWidth;
        canvasEl.height = canvasEl.clientHeight;
        ctxLocal.clearRect(0, 0, canvasEl.width, canvasEl.height);
        ctxLocal.fillStyle = getComputedCssVar(CSS_VARS.BG_COLOR);
        ctxLocal.fillRect(0, 0, canvasEl.width, canvasEl.height);
        const nodes = simBayesianNetwork.nodes;
        const sortedNodeNames = simBayesianNetwork.topologicalSort();
        if (!sortedNodeNames) { console.error("BN: Could not perform topological sort for visualization."); return; }
        const nodePositions = {}, layers = {}, nodeDepths = {};
        function getDepth(name) {
          if (nodeDepths[name] !== undefined) return nodeDepths[name];
          const node = nodes.get(name); if (!node) return -1;
          if (node.parents.length === 0) return nodeDepths[name] = 0;
          let d = -1; node.parents.forEach(p => { d = Math.max(d, getDepth(p.name)); });
          return nodeDepths[name] = d + 1;
        }
        sortedNodeNames.forEach(n => { const d = getDepth(n); if (!layers[d]) layers[d] = []; layers[d].push(n); });

        const PADDING_X = 30, PADDING_Y = 40;
        const NODE_WIDTH_BASE = 120, NODE_WIDTH_MAX = 170;
        const NODE_HEIGHT = 55, NODE_RADIUS = 8;
        const NODE_Y_SPACING_PER_LAYER_DEPTH = NODE_HEIGHT * 2.6;
        const MIN_NODE_SPACING_X_FACTOR = 1.2;
        const NAME_FONT_SIZE_BASE = 11, DETAIL_FONT_SIZE = 9;
        const DETAIL_Y_OFFSET_FROM_CENTER = NODE_HEIGHT / 2 - DETAIL_FONT_SIZE - 5;

        const sortedDepths = Object.keys(layers).map(Number).sort((a,b)=>a-b);
        const parentX = {};
        sortedDepths.forEach(depth => {
          const layerNodes = layers[depth];
          if (depth > 0) {
            layerNodes.sort((a,b)=>{
              const avg = name => {
                const n = nodes.get(name); if (!n || n.parents.length===0) return 0;
                let sum=0,c=0; n.parents.forEach(p=>{ if(parentX[p.name]!==undefined){ sum+=parentX[p.name]; c++; }});
                return c?sum/c:0;
              };
              return avg(a)-avg(b);
            });
          }
          const num = layerNodes.length;
          const dynamicNodeWidth = Math.max(NODE_WIDTH_BASE, Math.min(NODE_WIDTH_MAX, (canvasEl.width - PADDING_X*(num+1))/num));
          const nodeSpacingX = dynamicNodeWidth * MIN_NODE_SPACING_X_FACTOR;
          let totalWidth = num*dynamicNodeWidth + (num>1 ? (num-1)*(nodeSpacingX - dynamicNodeWidth) : 0);
          let startX = (canvasEl.width - totalWidth)/2; if (startX < PADDING_X) startX = PADDING_X;
          layerNodes.forEach((name, idx)=>{
            const x = startX + idx*nodeSpacingX + dynamicNodeWidth/2;
            const y = PADDING_Y + depth*NODE_Y_SPACING_PER_LAYER_DEPTH + NODE_HEIGHT/2;
            nodePositions[name] = { x, y, width: dynamicNodeWidth };
            parentX[name] = x;
          });
        });

        const edgeColor = getComputedCssVar(CSS_VARS.BN_EDGE_COLOR);
        const edgeColorPositive = getComputedCssVar(CSS_VARS.BN_EDGE_COLOR_POSITIVE);
        const edgeColorNegative = getComputedCssVar(CSS_VARS.BN_EDGE_COLOR_NEGATIVE);
        const arrowheadColor = getComputedCssVar(CSS_VARS.BN_ARROWHEAD_COLOR);
        const nodeParamBg = getComputedCssVar(CSS_VARS.BN_NODE_PARAM_BG);
        const nodeOutcomeBg = getComputedCssVar(CSS_VARS.BN_NODE_OUTCOME_BG);
        const nodeBorderColor = getComputedCssVar(CSS_VARS.BN_NODE_BORDER);
        const groupColors = {
          plant: getComputedCssVar(CSS_VARS.BN_GROUP_PLANT),
          prey: getComputedCssVar(CSS_VARS.BN_GROUP_PREY),
          predator: getComputedCssVar(CSS_VARS.BN_GROUP_PREDATOR),
          derived: getComputedCssVar(CSS_VARS.BN_GROUP_DERIVED),
          outcome: getComputedCssVar(CSS_VARS.BN_GROUP_OUTCOME)
        };

        sortedNodeNames.forEach(childName => {
          const childData = nodePositions[childName];
          const childNode = nodes.get(childName);
          if (!childData || !childNode) return;
          const childPos = { x: childData.x, y: childData.y };
          childNode.parents.forEach(parent => {
            const parentData = nodePositions[parent.name];
            if (!parentData) return;
            const parentPos = { x: parentData.x, y: parentData.y };
            const rawWeight = childNode.continuousParams.weights && childNode.continuousParams.weights[parent.name];
            const weight = rawWeight !== undefined ? Math.abs(rawWeight) : 1;
            const sign = rawWeight !== undefined ? Math.sign(rawWeight) : 0;
            ctxLocal.lineWidth = 1 + Math.min(4, weight*2);
            const strokeColor = sign < 0 ? edgeColorNegative : (sign > 0 ? edgeColorPositive : edgeColor);
            ctxLocal.strokeStyle = strokeColor;
            ctxLocal.globalAlpha = 0.4 + Math.min(0.6, weight/2);
            ctxLocal.beginPath();
            ctxLocal.moveTo(parentPos.x, parentPos.y);
            ctxLocal.lineTo(childPos.x, childPos.y);
            ctxLocal.stroke();
            ctxLocal.globalAlpha = 1;
            const angle = Math.atan2(childPos.y - parentPos.y, childPos.x - parentPos.x);
            const arrowSize = 8;
            const nodeBoundaryOffset = NODE_HEIGHT/2 + 3;
            ctxLocal.beginPath();
            ctxLocal.moveTo(childPos.x - nodeBoundaryOffset*Math.cos(angle), childPos.y - nodeBoundaryOffset*Math.sin(angle));
            ctxLocal.lineTo(childPos.x - nodeBoundaryOffset*Math.cos(angle) - arrowSize*Math.cos(angle - Math.PI/6), childPos.y - nodeBoundaryOffset*Math.sin(angle) - arrowSize*Math.sin(angle - Math.PI/6));
            ctxLocal.lineTo(childPos.x - nodeBoundaryOffset*Math.cos(angle) - arrowSize*Math.cos(angle + Math.PI/6), childPos.y - nodeBoundaryOffset*Math.sin(angle) - arrowSize*Math.sin(angle + Math.PI/6));
            ctxLocal.closePath();
            ctxLocal.fillStyle = strokeColor;
            ctxLocal.fill();
          });
        });

        ctxLocal.textAlign = 'center';
        ctxLocal.textBaseline = 'middle';
        Object.entries(nodePositions).forEach(([nodeName, nodeData]) => {
          const node = nodes.get(nodeName);
          if (!node) return;
          const pos = { x: nodeData.x, y: nodeData.y };
          const currentWidth = nodeData.width;
          const TEXT_MARGIN_X = 8;
          const maxTextWidth = currentWidth - TEXT_MARGIN_X*2;
          const groupColor = groupColors[getNodeGroup(nodeName)];
          ctxLocal.fillStyle = groupColor || (node.type === 'discrete' ? nodeOutcomeBg : nodeParamBg);
          ctxLocal.strokeStyle = nodeBorderColor;
          ctxLocal.lineWidth = 1.2;
          ctxLocal.beginPath();
          if (typeof ctxLocal.roundRect === 'function') {
            ctxLocal.roundRect(pos.x - currentWidth/2, pos.y - NODE_HEIGHT/2, currentWidth, NODE_HEIGHT, NODE_RADIUS);
          } else {
            ctxLocal.rect(pos.x - currentWidth/2, pos.y - NODE_HEIGHT/2, currentWidth, NODE_HEIGHT);
          }
          ctxLocal.fill();
          ctxLocal.stroke();
          let detailText = '';
          if (node.type === 'discrete' && node.states) {
            if (node.parents.length === 0 && node.cpt) {
              detailText = '(' + node.states.map(s => `${s}:${(node.cpt[s] ?? 0).toFixed(2)}`).join(', ') + ')';
            } else {
              detailText = '(' + node.states.join(', ') + ')';
            }
          } else if (node.type === 'continuous') {
            const pConf = allBnParamAndDerivedNodeConfigs.find(pc => pc.name === node.name);
            if (pConf && pConf.min !== undefined && pConf.max !== undefined) {
              let precision = 2;
              if (pConf.isTunable) {
                const paramDef = tunableParams.find(tp => tp.configKey === pConf.configKey);
                if (paramDef) precision = getPrecision(paramDef.step);
              } else {
                precision = (pConf.max - pConf.min) < 10 ? 2 : ((pConf.max - pConf.min) < 1 ? 3 : 1);
                if (pConf.step) precision = getPrecision(pConf.step);
                else if ((pConf.max - pConf.min) === 0) precision = 0;
              }
              detailText = `[${pConf.min.toFixed(precision)}-${pConf.max.toFixed(precision)}]`;
            } else if (node.min !== undefined && node.max !== undefined) {
              detailText = `[${node.min.toFixed(2)}-${node.max.toFixed(2)}]`;
            }
          }
          wrapAndDrawText(ctxLocal, nodeName, pos.x, pos.y, maxTextWidth, NAME_FONT_SIZE_BASE, DETAIL_FONT_SIZE, DETAIL_Y_OFFSET_FROM_CENTER, detailText);
        });
        bnLastNodePositions = nodePositions;
      }
    function populateBNLegend() {
      const legendDiv = DOM_ELEMENTS.bnLegend;
      if (!legendDiv) return;
      legendDiv.innerHTML = "";
      const nodeParamBg = getComputedCssVar(CSS_VARS.BN_NODE_PARAM_BG);
      const nodeOutcomeBg = getComputedCssVar(CSS_VARS.BN_NODE_OUTCOME_BG);
      const edgeColor = getComputedCssVar(CSS_VARS.BN_EDGE_COLOR);
      const posEdgeColor = getComputedCssVar(CSS_VARS.BN_EDGE_COLOR_POSITIVE);
      const negEdgeColor = getComputedCssVar(CSS_VARS.BN_EDGE_COLOR_NEGATIVE);
      const plantColor = getComputedCssVar(CSS_VARS.BN_GROUP_PLANT);
      const preyColor = getComputedCssVar(CSS_VARS.BN_GROUP_PREY);
      const predColor = getComputedCssVar(CSS_VARS.BN_GROUP_PREDATOR);
      const derivedColor = getComputedCssVar(CSS_VARS.BN_GROUP_DERIVED);
      const outcomeColor = getComputedCssVar(CSS_VARS.BN_GROUP_OUTCOME);
      legendDiv.appendChild(createLegendItem(plantColor, 'Plant'));
      legendDiv.appendChild(createLegendItem(preyColor, 'Prey'));
      legendDiv.appendChild(createLegendItem(predColor, 'Predator'));
      legendDiv.appendChild(createLegendItem(derivedColor, 'Derived'));
      legendDiv.appendChild(createLegendItem(outcomeColor, 'Outcome'));
      const edgeLegendItemPos = document.createElement('div');
      edgeLegendItemPos.className = 'legend-item';
      edgeLegendItemPos.innerHTML = `<span class="legend-color-swatch" style="background-color: transparent; border:none; display:inline-flex; align-items:center; margin-right: 6px; position:relative; top:1px;"><svg width="12" height="12" viewBox="0 0 12 12" style="overflow:visible;"><line x1="0" y1="6" x2="12" y2="6" stroke="${posEdgeColor}" stroke-width="1.5"/><polygon points="11,6 7,4 7,8" fill="${posEdgeColor}"/></svg></span> Positive Influence`;
      legendDiv.appendChild(edgeLegendItemPos);
      const edgeLegendItemNeg = document.createElement('div');
      edgeLegendItemNeg.className = 'legend-item';
      edgeLegendItemNeg.innerHTML = `<span class="legend-color-swatch" style="background-color: transparent; border:none; display:inline-flex; align-items:center; margin-right: 6px; position:relative; top:1px;"><svg width="12" height="12" viewBox="0 0 12 12" style="overflow:visible;"><line x1="0" y1="6" x2="12" y2="6" stroke="${negEdgeColor}" stroke-width="1.5"/><polygon points="11,6 7,4 7,8" fill="${negEdgeColor}"/></svg></span> Negative Influence`;
      legendDiv.appendChild(edgeLegendItemNeg);
    }

      function exportBNAsImage() {
        if (!bnVisualizationCanvas) return;
        const link = document.createElement('a');
        link.download = 'bayesian_network.png';
        link.href = bnVisualizationCanvas.toDataURL('image/png');
        link.click();
    }

    function exportBNAsSVG() {
      if (!simBayesianNetwork || !bnVisualizationCanvas) return;
      drawBayesianNetworkVisualization();
      const width = bnVisualizationCanvas.width;
      const height = bnVisualizationCanvas.height;
      let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">`;
      Object.values(bnLastNodePositions).forEach(pos => {
        svg += `<rect x="${pos.x - pos.width/2}" y="${pos.y - 27.5}" width="${pos.width}" height="55" rx="8" ry="8" fill="white" stroke="black" stroke-width="1"/>`;
      });
      svg += `</svg>`;
        const blob = new Blob([svg], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'bayesian_network.svg';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function exportRunsData() { const dataToExport = { version: SIM_DATA_VERSION, initialConfigSnapshot, completedRuns }; const jsonData = JSON.stringify(dataToExport, null, 2); const blob = new Blob([jsonData], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); const date = new Date(); const dateString = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`; a.download = `ecosystem_runs_data_${dateString}.json`; a.href = url; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); console.log("Exported runs data."); }
    function importRunsData(event) {
      const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (e) => {
        try {
          const importedObject = JSON.parse(e.target.result); let importedRuns, importedInitialConfigSnapshot; if (importedObject.version >= 1 && importedObject.completedRuns && importedObject.initialConfigSnapshot) { importedRuns = importedObject.completedRuns; importedInitialConfigSnapshot = importedObject.initialConfigSnapshot; } else if (Array.isArray(importedObject)) { importedRuns = importedObject; importedInitialConfigSnapshot = structuredClone(config); console.log("Imported legacy data. Using current app defaults for comparison."); } else throw new Error("Invalid data format."); if (!Array.isArray(importedRuns)) throw new Error("Completed runs data not an array."); if (importedRuns.length > 0 && (!importedRuns[0].parameters || !importedRuns[0].statistics)) throw new Error("Run data malformed."); completedRuns = importedRuns; initialConfigSnapshot = importedInitialConfigSnapshot; console.log(`Imported ${completedRuns.length} runs.`); alert(`Successfully imported ${completedRuns.length} runs.`); adaptBNBinCountIfNeeded();
          gpOptimizer.observations = [];
          completedRuns.forEach(run => {
            if (run.durationFrames > 30) {
              const scoreForGP = calculateAutoPilotScore(run);
              gpOptimizer.addObservation(run.parameters, scoreForGP);
            }
          });
          resetAutoPilotStats(); currentRunNumber = completedRuns.length > 0 ? Math.max(...completedRuns.map(r => r.runNumber), 0) : 0; populatePastRunsSummaryList(); updateCurrentBNPredictionsDisplay(); if (DOM_ELEMENTS.pastRunDetails.style.display === 'block') DOM_ELEMENTS.pastRunDetails.style.display = 'none';
        } catch (err) { console.error("Error importing data:", err); alert(`Error importing data: ${err.message}`); } finally { event.target.value = null; }
      }; reader.readAsText(file);
    }

  function drawBNPredictionGraph() {
      const yMax = 1.05; // Probabilities are 0-1, give a little padding
      const histories = [
        {
          data: bnPredictionHistory.plantExtinctionProb,
          color: getComputedCssVar(CSS_VARS.PLANT_COLOR),
          lineWidth: 1.5,
          label: "P(Plant Extinct)",
          visible: true
        },
        {
          data: bnPredictionHistory.preyExtinctionProb,
          color: getComputedCssVar(CSS_VARS.PREY_COLOR),
          lineWidth: 1.5,
          label: "P(Prey Extinct)",
          visible: true
        },
        {
          data: bnPredictionHistory.predatorExtinctionProb,
          color: getComputedCssVar(CSS_VARS.PREDATOR_COLOR),
          lineWidth: 1.5,
          label: "P(Pred Extinct)",
          visible: true
        },
        { data: bnPredictionHistory.favorableGrowthPlantProb,
          color: modifyHslColor(getComputedCssVar(CSS_VARS.PLANT_COLOR), 1, 1.2),
          lineWidth: 1.5,
          label: "P(Plant Growth)",
          visible: true
        },
        {
          data: bnPredictionHistory.favorableGrowthPreyProb,
          color: modifyHslColor(getComputedCssVar(CSS_VARS.PREY_COLOR), 1, 1.2),
          lineWidth: 1.5,
          label: "P(Prey Growth)",
          visible: true
        },
        {
          data: bnPredictionHistory.favorableGrowthPredatorProb,
          color: modifyHslColor(getComputedCssVar(CSS_VARS.PREDATOR_COLOR), 1, 1.2),
          lineWidth: 1.5,
          label: "P(Pred Growth)",
          visible: true
        }, // Lighter pred color
        { 
          data: bnPredictionHistory.preyStarvationRiskProb,
          color: modifyHslColor(getComputedCssVar(CSS_VARS.PREY_COLOR), 0.8, 0.8),
          lineWidth: 1.5, 
          label: "P(Prey Starv. Risk)", 
          visible: true 
        },
        { 
          data: bnPredictionHistory.predatorStarvationRiskProb, 
          color: modifyHslColor(getComputedCssVar(CSS_VARS.PREDATOR_COLOR), 0.8, 0.8), 
          lineWidth: 1.5, 
          label: "P(Pred Starv. Risk)", 
          visible: true 
  }

    function drawBNPredictionExtinctionGraph() {
      const yMax = 1.05;
      const histories = [
        { data: bnPredictionHistory.plantExtinctionProb, color: getComputedCssVar(CSS_VARS.PLANT_COLOR), lineWidth: 1.5, label: "P(Plant Extinct)", visible: true },
        { data: bnPredictionHistory.preyExtinctionProb, color: getComputedCssVar(CSS_VARS.PREY_COLOR), lineWidth: 1.5, label: "P(Prey Extinct)", visible: true },
        { data: bnPredictionHistory.predatorExtinctionProb, color: getComputedCssVar(CSS_VARS.PREDATOR_COLOR), lineWidth: 1.5, label: "P(Pred Extinct)", visible: true }
      ];
      drawGenericGraph(bnPredictionExtinctionGraphCtx, bnPredictionExtinctionGraphCanvas, histories, bnPredictionHistory.maxLength, yMax, true);
      if (DOM_ELEMENTS.bnPredictionExtinctionGraphLegend) {
        populateGraphLegend('bnPredictionExtinctionGraphLegend', histories, drawBNPredictionExtinctionGraph);
      }
    }

    function drawBNPredictionGrowthGraph() {
      const yMax = 1.05;
      const histories = [
        { data: bnPredictionHistory.favorableGrowthPlantProb, color: modifyHslColor(getComputedCssVar(CSS_VARS.PLANT_COLOR), 1, 1.2), lineWidth: 1.5, label: "P(Plant Growth)", visible: true },
        { data: bnPredictionHistory.favorableGrowthPreyProb, color: modifyHslColor(getComputedCssVar(CSS_VARS.PREY_COLOR), 1, 1.2), lineWidth: 1.5, label: "P(Prey Growth)", visible: true },
        { data: bnPredictionHistory.favorableGrowthPredatorProb, color: modifyHslColor(getComputedCssVar(CSS_VARS.PREDATOR_COLOR), 1, 1.2), lineWidth: 1.5, label: "P(Pred Growth)", visible: true }
      ];
      drawGenericGraph(bnPredictionGrowthGraphCtx, bnPredictionGrowthGraphCanvas, histories, bnPredictionHistory.maxLength, yMax, true);
      if (DOM_ELEMENTS.bnPredictionGrowthGraphLegend) {
        populateGraphLegend('bnPredictionGrowthGraphLegend', histories, drawBNPredictionGrowthGraph);
      }
    }

    function drawBNPredictionStarvationGraph() {
      const yMax = 1.05;
      const histories = [
        { data: bnPredictionHistory.preyStarvationRiskProb, color: modifyHslColor(getComputedCssVar(CSS_VARS.PREY_COLOR), 0.8, 0.8), lineWidth: 1.5, label: "P(Prey Starv. Risk)", visible: true },
        { data: bnPredictionHistory.predatorStarvationRiskProb, color: modifyHslColor(getComputedCssVar(CSS_VARS.PREDATOR_COLOR), 0.8, 0.8), lineWidth: 1.5, label: "P(Pred Starv. Risk)", visible: true }
      ];
      drawGenericGraph(bnPredictionStarvationGraphCtx, bnPredictionStarvationGraphCanvas, histories, bnPredictionHistory.maxLength, yMax, true);
      if (DOM_ELEMENTS.bnPredictionStarvationGraphLegend) {
        populateGraphLegend('bnPredictionStarvationGraphLegend', histories, drawBNPredictionStarvationGraph);
      }
    }
      ];

      drawGenericGraph(bnPredictionGraphCtx, bnPredictionGraphCanvas, histories, bnPredictionHistory.maxLength, yMax, true);

      if (DOM_ELEMENTS.bnPredictionGraphLegend) {
        populateGraphLegend('bnPredictionGraphLegend', histories, drawBNPredictionGraph);
      }
    }

    function drawBNPredictionErrorGraph() {
      const yMax = 1.05;
      const histories = [
        {
          data: bnPredictionErrorHistory.errors,
          color: getComputedCssVar(CSS_VARS.GRAPH_BN_ERROR_COLOR),
          lineWidth: 1.5,
          label: 'Avg Abs Error'
        }
      ];
      drawGenericGraph(bnPredictionErrorGraphCtx, bnPredictionErrorGraphCanvas, histories, bnPredictionErrorHistory.maxLength, yMax, true);
      if (DOM_ELEMENTS.bnPredictionErrorGraphLegend) {
        populateGraphLegend('bnPredictionErrorGraphLegend', histories);
      }
    }

    // Modify drawGenericGraph to accept optional fixed yMax and y-axis scaling for probabilities
    function drawGenericGraph(graphCtxLocal, canvasLocal, histories, maxLength, fixedYMax = null, scaleYForProbability = false, areaMode = false, stackedArea = false) {
      if (!canvasLocal || canvasLocal.width === 0 || canvasLocal.height === 0) return;

      const bgColor = getComputedCssVar(CSS_VARS.BG_COLOR);
      const gridColor = getComputedCssVar(CSS_VARS.GRAPH_GRID_COLOR);
      const textColor = getComputedCssVar(CSS_VARS.TEXT_COLOR_DARKER);

      graphCtxLocal.fillStyle = bgColor;
      graphCtxLocal.fillRect(0, 0, canvasLocal.width, canvasLocal.height);

      let maxVal;
      if (fixedYMax !== null) {
        maxVal = fixedYMax;
      } else if (areaMode && stackedArea) {
        maxVal = 10;
        for (let i = 0; i < maxLength; i++) {
          let sum = 0;
          histories.forEach(h => { if (h.data && h.data[i] !== undefined && h.visible !== false) sum += h.data[i]; });
          if (sum > maxVal) maxVal = sum;
        }
        maxVal = Math.ceil(maxVal / 10) * 10;
        if (maxVal === 0) maxVal = 10;
      } else {
        maxVal = 10;
        histories.forEach(h => { if (h.data) h.data.forEach(val => { if (val > maxVal) maxVal = val; }) });
        maxVal = Math.ceil(maxVal / 10) * 10;
        if (maxVal === 0) maxVal = 10;
      }

      const padding = { top: 20, right: 20, bottom: 30, left: 35 }; // Increased left padding for probability labels
      const chartWidth = canvasLocal.width - padding.left - padding.right;
      const chartHeight = canvasLocal.height - padding.top - padding.bottom;

      if (chartWidth <= 0 || chartHeight <= 0) return;

      graphCtxLocal.strokeStyle = gridColor;
      graphCtxLocal.lineWidth = 0.5;
      graphCtxLocal.font = '10px Inter, sans-serif';
      graphCtxLocal.fillStyle = textColor;
      graphCtxLocal.textAlign = 'right';
      graphCtxLocal.textBaseline = 'middle';

      const numYGridLines = scaleYForProbability ? 5 : 5; // e.g. 0, 0.25, 0.5, 0.75, 1.0
      for (let i = 0; i <= numYGridLines; i++) {
        const y = padding.top + (chartHeight / numYGridLines) * i;
        graphCtxLocal.beginPath();
        graphCtxLocal.moveTo(padding.left, y);
        graphCtxLocal.lineTo(padding.left + chartWidth, y);
        graphCtxLocal.stroke();
        let labelValue = maxVal * (1 - i / numYGridLines);
        if (scaleYForProbability) {
          labelValue = parseFloat(labelValue.toFixed(2)); // For probabilities like 0.25, 0.50
        } else {
          labelValue = Math.round(labelValue);
        }
        graphCtxLocal.fillText(labelValue, padding.left - 5, y);
      }

      graphCtxLocal.textAlign = 'center';
      graphCtxLocal.textBaseline = 'top';
      const numXLabels = 4;
      for (let i = 0; i <= numXLabels; i++) {
        const x = padding.left + (chartWidth / numXLabels) * i;
        graphCtxLocal.beginPath();
        graphCtxLocal.moveTo(x, padding.top);
        graphCtxLocal.lineTo(x, padding.top + chartHeight);
        graphCtxLocal.stroke();

        if (i === 0 || i === numXLabels || i === Math.floor(numXLabels / 2) || numXLabels <= 4) {
          // Label x-axis with history points (relative time) for BN prediction graph
          const frameLabel = Math.round((maxLength / numXLabels) * i);
          graphCtxLocal.fillText(frameLabel, x, padding.top + chartHeight + 5);
        }
      }


      const xStep = chartWidth / Math.max(1, maxLength - 1);

      if (areaMode) {
        const baseline = new Array(maxLength).fill(0);
        histories.forEach(h => {
          if (!h.data || h.data.length < 2 || h.visible === false) return;
          graphCtxLocal.beginPath();
          h.data.forEach((val, index) => {
            const x = padding.left + index * xStep;
            const yBase = padding.top + chartHeight - (baseline[index] / maxVal) * chartHeight;
            if (index === 0) graphCtxLocal.moveTo(x, yBase);
            else graphCtxLocal.lineTo(x, yBase);
          });
          for (let i = h.data.length - 1; i >= 0; i--) {
            const x = padding.left + i * xStep;
            const yTop = padding.top + chartHeight - ((baseline[i] + h.data[i]) / maxVal) * chartHeight;
            graphCtxLocal.lineTo(x, yTop);
          }
          graphCtxLocal.closePath();
          graphCtxLocal.fillStyle = h.color;
          graphCtxLocal.fill();
          for (let i = 0; i < h.data.length; i++) baseline[i] += h.data[i];
        });
      } else {
        histories.forEach(h => {
          if (!h.data || h.data.length < 2 || h.visible === false) return;
          graphCtxLocal.beginPath();
          graphCtxLocal.strokeStyle = h.color;
          graphCtxLocal.lineWidth = h.lineWidth || 2;
          h.data.forEach((val, index) => {
            const x = padding.left + index * xStep;
            const y = padding.top + chartHeight - (Math.min(val, maxVal) / maxVal) * chartHeight;
            if (index === 0) graphCtxLocal.moveTo(x, y);
            else graphCtxLocal.lineTo(x, y);
          });
          graphCtxLocal.stroke();
        });
      }

      canvasLocal._graphInfo = { histories, maxLength, xStep, padding, chartHeight, maxVal };
      if (!canvasLocal._tooltipHandlersAdded) {
        canvasLocal.addEventListener('mousemove', function(evt) {
          if (!graphTooltip) return;
          const info = canvasLocal._graphInfo;
          if (!info) return;
          const rect = canvasLocal.getBoundingClientRect();
          const relX = evt.clientX - rect.left - info.padding.left;
          const index = Math.round(relX / info.xStep);
          if (index < 0 || index >= info.maxLength) { graphTooltip.style.display = 'none'; return; }
          let html = `t=${index * historyUpdateInterval}`;
          info.histories.forEach(h => {
            if (h.visible === false) return;
            const val = h.data[index];
            if (val !== undefined) html += `<br>${h.label}: ${val}`;
          });
          graphTooltip.innerHTML = html;
          graphTooltip.style.left = `${evt.clientX + 10}px`;
          graphTooltip.style.top = `${evt.clientY + 10}px`;
          graphTooltip.style.display = 'block';
        });
        canvasLocal.addEventListener('mouseleave', () => { if (graphTooltip) graphTooltip.style.display = 'none'; });
        canvasLocal._tooltipHandlersAdded = true;
      }
    }

    function cacheDOMElements() {
      const ids = [
        'simulationCanvas', 'populationGraphCanvas', 'cumulativeGraphCanvas',
        'pastPopulationGraphCanvas', 'pastCumulativeGraphCanvas', 'bayesianNetworkVisualizationCanvas',
        'simulationViewContainer', 'pastRunsViewContainer', 'bayesianNetworkVisualizationContainer',
        'pageHeader', 'pageSubheader', 'statsToggle', 'statsOverlay', 'controlsToggle', 'controlsOverlay',
        'fpsDisplay', 'bnAccuracyDisplay', 'plantCount', 'preyCount', 'predatorCount', 'totalEntities',
        'plantBirthsDisplay', 'plantsConsumedDisplay', 'preyBirthsDisplay', 'predatorBirthsDisplay',
        'totalPreyDeathsDisplay', 'totalPredatorDeathsDisplay',
        'preyPredationDeathsDisplay', 'preyStarvationDeathsDisplay',
        'predatorStarvationDeathsDisplay', 'predatorMobbingDeathsDisplay',
        'bnCurrentPreyExtinctionPrediction', 'bnCurrentPredatorExtinctionPrediction',
        'bnCurrentPlantGrowthPrediction', 'bnCurrentPreyGrowthPrediction', 'bnCurrentPredatorGrowthPrediction',
        'bnCurrentPreyStarvationRiskPrediction', 'bnCurrentPredStarvationRiskPrediction', // New DOM elements
        'planktonMode', 'preyKillPredatorsMode', 'showTargetLines', 'simulationSpeed', 'simulationSpeedValue',
        'exportRunsButton', 'importRunsFile', 'resetSimulation', 'autoPilotRun',
        'pastRunsToggleMain', 'currentRunInfo', 'currentRunDisplay', 'explorationFactorDisplay',
        'autoPilotLastScoreDisplay', 'autoPilotBestScoreDisplay', 'bnErrorAvgDisplay',
        'backToSimulationButton', 'noPastRunsMessage', 'pastRunsSummaryList', 'pastRunDetails',
        'pastRunNumberDisplay', 'pastRunScoreDisplay', 'pastRunAutoPilotScoreDisplay',
        'pastRunParamsDisplay', 'pastRunStatsDisplay',
          'pastPopulationGraphLegend', 'pastCumulativeGraphLegend', 'bnLegend', 'exportBNPngButton', 'exportBNSvgButton',
        'currentPopulationGraphLegend', 'currentCumulativeGraphLegend',
        'bnRunStartPreyExtinctionPrediction', 'bnRunStartPredatorExtinctionPrediction',
        'bnRunStartPlantGrowthPrediction', 'bnRunStartPreyGrowthPrediction',
        'bnRunStartPredatorGrowthPrediction', 'bnRunStartPreyStarvationRiskPrediction',
        'bnRunStartPredStarvationRiskPrediction',
        'bnPredictionGraphCanvas', 'bnPredictionGraphLegend',
        'bnPredictionExtinctionGraphCanvas', 'bnPredictionExtinctionGraphLegend',
        'bnPredictionGrowthGraphCanvas', 'bnPredictionGrowthGraphLegend',
        'bnPredictionStarvationGraphCanvas', 'bnPredictionStarvationGraphLegend',
        'bnPredictionErrorGraphCanvas', 'bnPredictionErrorGraphLegend',
        'pastBNPredictionGraphCanvas', 'pastBNPredictionGraphLegend',
        'pastBNPredictionExtinctionGraphCanvas', 'pastBNPredictionExtinctionGraphLegend',
        'pastBNPredictionGrowthGraphCanvas', 'pastBNPredictionGrowthGraphLegend',
        'pastBNPredictionStarvationGraphCanvas', 'pastBNPredictionStarvationGraphLegend',
        'graphTooltip',
        // Add new elements
      ];
      tunableParams.forEach(param => { ids.push(param.id); ids.push(param.id + "Value"); });
      ids.forEach(id => DOM_ELEMENTS[id] = document.getElementById(id));

      // Canvas contexts
      canvas = DOM_ELEMENTS.simulationCanvas; ctx = canvas.getContext('2d');
      populationGraphCanvas = DOM_ELEMENTS.populationGraphCanvas; populationGraphCtx = populationGraphCanvas.getContext('2d');
      cumulativeGraphCanvas = DOM_ELEMENTS.cumulativeGraphCanvas; cumulativeGraphCtx = cumulativeGraphCanvas.getContext('2d');
      pastPopulationGraphCanvas = DOM_ELEMENTS.pastPopulationGraphCanvas; pastPopulationGraphCtx = pastPopulationGraphCanvas.getContext('2d');
      pastCumulativeGraphCanvas = DOM_ELEMENTS.pastCumulativeGraphCanvas; pastCumulativeGraphCtx = pastCumulativeGraphCanvas.getContext('2d');
      bnVisualizationCanvas = DOM_ELEMENTS.bayesianNetworkVisualizationCanvas; bnVisualizationCtx = bnVisualizationCanvas.getContext('2d');

      bnPredictionGraphCanvas = DOM_ELEMENTS.bnPredictionGraphCanvas; // Cache new canvas
      if (bnPredictionGraphCanvas) bnPredictionGraphCtx = bnPredictionGraphCanvas.getContext('2d'); // Get context
      bnPredictionExtinctionGraphCanvas = DOM_ELEMENTS.bnPredictionExtinctionGraphCanvas;
      if (bnPredictionExtinctionGraphCanvas) bnPredictionExtinctionGraphCtx = bnPredictionExtinctionGraphCanvas.getContext('2d');
      bnPredictionGrowthGraphCanvas = DOM_ELEMENTS.bnPredictionGrowthGraphCanvas;
      if (bnPredictionGrowthGraphCanvas) bnPredictionGrowthGraphCtx = bnPredictionGrowthGraphCanvas.getContext('2d');
      bnPredictionStarvationGraphCanvas = DOM_ELEMENTS.bnPredictionStarvationGraphCanvas;
      if (bnPredictionStarvationGraphCanvas) bnPredictionStarvationGraphCtx = bnPredictionStarvationGraphCanvas.getContext('2d');
      bnPredictionErrorGraphCanvas = DOM_ELEMENTS.bnPredictionErrorGraphCanvas;
      if (bnPredictionErrorGraphCanvas) bnPredictionErrorGraphCtx = bnPredictionErrorGraphCanvas.getContext('2d');
      pastBNPredictionGraphCanvas = DOM_ELEMENTS.pastBNPredictionGraphCanvas;
      if (pastBNPredictionGraphCanvas) pastBNPredictionGraphCtx = pastBNPredictionGraphCanvas.getContext('2d');
      pastBNPredictionExtinctionGraphCanvas = DOM_ELEMENTS.pastBNPredictionExtinctionGraphCanvas;
      if (pastBNPredictionExtinctionGraphCanvas) pastBNPredictionExtinctionGraphCtx = pastBNPredictionExtinctionGraphCanvas.getContext('2d');
      pastBNPredictionGrowthGraphCanvas = DOM_ELEMENTS.pastBNPredictionGrowthGraphCanvas;
      if (pastBNPredictionGrowthGraphCanvas) pastBNPredictionGrowthGraphCtx = pastBNPredictionGrowthGraphCanvas.getContext('2d');
      pastBNPredictionStarvationGraphCanvas = DOM_ELEMENTS.pastBNPredictionStarvationGraphCanvas;
      if (pastBNPredictionStarvationGraphCanvas) pastBNPredictionStarvationGraphCtx = pastBNPredictionStarvationGraphCanvas.getContext('2d');
      // Main view containers
      simulationViewContainer = DOM_ELEMENTS.simulationViewContainer;
      pastRunsViewContainer = DOM_ELEMENTS.pastRunsViewContainer;
      bnVisualizationContainer = DOM_ELEMENTS.bayesianNetworkVisualizationContainer;
      graphTooltip = DOM_ELEMENTS.graphTooltip;
    }

    function init() {
      cacheDOMElements();
      canvas.width = window.innerWidth; canvas.height = window.innerHeight;
      document.body.style.overflow = 'hidden'; // Default to hidden for sim view

      getUrlParams(); // Apply URL params like ?hue=...
      initialConfigSnapshot = structuredClone(config); // Snapshot initial state for comparison

      setupControls(); // Initialize UI controls and their listeners

      // Initialize Gaussian Process Optimizer with info about tunable parameters for normalization
      const gpNormalizationParamInfo = tunableParams.map(tp => ({
        configKey: tp.configKey,
        min: tp.min,
        max: tp.max
      }));
      // Add boolean flags to GP normalization info as 0 or 1 (as they are also "tuned" by Autopilot)
      gpNormalizationParamInfo.push({ configKey: 'planktonMode', min: 0, max: 1 });
      gpNormalizationParamInfo.push({ configKey: 'preyKillPredatorsMode', min: 0, max: 1 });
      gpOptimizer = new SimpleGaussianProcess(gpNormalizationParamInfo);

      adaptBNBinCountIfNeeded(); // Initialize BN with appropriate bin count

      // Initialize run state
      currentRunNumber = 0; // Will be incremented to 1 by startNewRun
      currentRunDeathFrames = { plant: null, prey: null, predator: null };
      simulationTimeAccumulator = 0;

      // Make initial BN predictions for the very first run's parameters
      let bnExtPreds = null, bnGrowthPreds = null, bnStarvPreds = null;
      const currentEffectiveConfig = structuredClone(config); // Use current state of config
      if (isBNReady()) { // BN won't be "ready" initially, but this structure is for consistency
        bnExtPreds = predictExtinctionProbabilities(currentEffectiveConfig);
        bnGrowthPreds = predictFavorableGrowth(currentEffectiveConfig);
        bnStarvPreds = predictStarvationRiskProbabilities(currentEffectiveConfig);
      }
      bnPredictionsForNextRun = { extinction: bnExtPreds, growth: bnGrowthPreds, starvationRisk: bnStarvPreds };
      updateRunStartBNPredictionsDisplay();
      updateCurrentBNPredictionsDisplay(); // Show these predictions
      updateBnAccuracyDisplay();
      updateAutoPilotStatsDisplay();

      // Start the first run with the initial (potentially URL-modified) config
      startNewRun(currentEffectiveConfig);
    }

    window.addEventListener('resize', () => {
      if (simulationViewContainer.style.display !== 'none') { // If simulation view is active
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        // Resize and redraw graphs if stats overlay is visible
        if (DOM_ELEMENTS.statsOverlay.classList.contains('visible')) {
          if (populationGraphCanvas.clientWidth > 0) populationGraphCanvas.width = populationGraphCanvas.clientWidth;
          if (populationGraphCanvas.clientHeight > 0) populationGraphCanvas.height = populationGraphCanvas.clientHeight;
          if (cumulativeGraphCanvas.clientWidth > 0) cumulativeGraphCanvas.width = cumulativeGraphCanvas.clientWidth;
          if (cumulativeGraphCanvas.clientHeight > 0) cumulativeGraphCanvas.height = cumulativeGraphCanvas.clientHeight;
          if (bnPredictionGraphCanvas && bnPredictionGraphCanvas.clientWidth > 0) bnPredictionGraphCanvas.width = bnPredictionGraphCanvas.clientWidth;
          if (bnPredictionGraphCanvas && bnPredictionGraphCanvas.clientHeight > 0) bnPredictionGraphCanvas.height = bnPredictionGraphCanvas.clientHeight;
          if (bnPredictionExtinctionGraphCanvas && bnPredictionExtinctionGraphCanvas.clientWidth > 0) bnPredictionExtinctionGraphCanvas.width = bnPredictionExtinctionGraphCanvas.clientWidth;
          if (bnPredictionExtinctionGraphCanvas && bnPredictionExtinctionGraphCanvas.clientHeight > 0) bnPredictionExtinctionGraphCanvas.height = bnPredictionExtinctionGraphCanvas.clientHeight;
          if (bnPredictionGrowthGraphCanvas && bnPredictionGrowthGraphCanvas.clientWidth > 0) bnPredictionGrowthGraphCanvas.width = bnPredictionGrowthGraphCanvas.clientWidth;
          if (bnPredictionGrowthGraphCanvas && bnPredictionGrowthGraphCanvas.clientHeight > 0) bnPredictionGrowthGraphCanvas.height = bnPredictionGrowthGraphCanvas.clientHeight;
          if (bnPredictionStarvationGraphCanvas && bnPredictionStarvationGraphCanvas.clientWidth > 0) bnPredictionStarvationGraphCanvas.width = bnPredictionStarvationGraphCanvas.clientWidth;
          if (bnPredictionStarvationGraphCanvas && bnPredictionStarvationGraphCanvas.clientHeight > 0) bnPredictionStarvationGraphCanvas.height = bnPredictionStarvationGraphCanvas.clientHeight;
          if (bnPredictionErrorGraphCanvas && bnPredictionErrorGraphCanvas.clientWidth > 0) bnPredictionErrorGraphCanvas.width = bnPredictionErrorGraphCanvas.clientWidth;
          if (bnPredictionErrorGraphCanvas && bnPredictionErrorGraphCanvas.clientHeight > 0) bnPredictionErrorGraphCanvas.height = bnPredictionErrorGraphCanvas.clientHeight;
          drawPopulationGraph();
          drawCumulativeGraph();
          if (bnPredictionGraphCanvas) drawBNPredictionGraph();
          if (bnPredictionExtinctionGraphCanvas) drawBNPredictionExtinctionGraph();
          if (bnPredictionGrowthGraphCanvas) drawBNPredictionGrowthGraph();
          if (bnPredictionStarvationGraphCanvas) drawBNPredictionStarvationGraph();
          if (bnPredictionErrorGraphCanvas) drawBNPredictionErrorGraph();
        }
      } else { // If past runs view is active
        // Resize and redraw graphs in past run details view if visible
        if (DOM_ELEMENTS.pastRunDetails.style.display === 'block') {
          const activeSummaryItem = DOM_ELEMENTS.pastRunsSummaryList.querySelector('.past-run-summary-item.active-selection');
          if (activeSummaryItem && activeSummaryItem.dataset.runIndex !== undefined) {
            const runIdx = parseInt(activeSummaryItem.dataset.runIndex);
            if (runIdx >= 0 && runIdx < completedRuns.length) {
              setTimeout(() => displayPastRunDetails(runIdx), 50); // Redraw with a slight delay
            }
          } else if (pastPopulationGraphCanvas && pastCumulativeGraphCanvas && pastBNPredictionGraphCanvas) { // Fallback if no item selected but canvases exist
            if (pastPopulationGraphCanvas.clientWidth > 0) pastPopulationGraphCanvas.width = pastPopulationGraphCanvas.clientWidth;
            if (pastPopulationGraphCanvas.clientHeight > 0) pastPopulationGraphCanvas.height = pastPopulationGraphCanvas.clientHeight || 200;
            if (pastCumulativeGraphCanvas.clientWidth > 0) pastCumulativeGraphCanvas.width = pastCumulativeGraphCanvas.clientWidth;
            if (pastCumulativeGraphCanvas.clientHeight > 0) pastCumulativeGraphCanvas.height = pastCumulativeGraphCanvas.clientHeight || 200;
            if (pastBNPredictionGraphCanvas.clientWidth > 0) pastBNPredictionGraphCanvas.width = pastBNPredictionGraphCanvas.clientWidth;
            if (pastBNPredictionGraphCanvas.clientHeight > 0) pastBNPredictionGraphCanvas.height = pastBNPredictionGraphCanvas.clientHeight || 200;
            if (pastBNPredictionExtinctionGraphCanvas.clientWidth > 0) pastBNPredictionExtinctionGraphCanvas.width = pastBNPredictionExtinctionGraphCanvas.clientWidth;
            if (pastBNPredictionExtinctionGraphCanvas.clientHeight > 0) pastBNPredictionExtinctionGraphCanvas.height = pastBNPredictionExtinctionGraphCanvas.clientHeight || 200;
            if (pastBNPredictionGrowthGraphCanvas.clientWidth > 0) pastBNPredictionGrowthGraphCanvas.width = pastBNPredictionGrowthGraphCanvas.clientWidth;
            if (pastBNPredictionGrowthGraphCanvas.clientHeight > 0) pastBNPredictionGrowthGraphCanvas.height = pastBNPredictionGrowthGraphCanvas.clientHeight || 200;
            if (pastBNPredictionStarvationGraphCanvas.clientWidth > 0) pastBNPredictionStarvationGraphCanvas.width = pastBNPredictionStarvationGraphCanvas.clientWidth;
            if (pastBNPredictionStarvationGraphCanvas.clientHeight > 0) pastBNPredictionStarvationGraphCanvas.height = pastBNPredictionStarvationGraphCanvas.clientHeight || 200;
          }
        }
        // Resize and redraw BN visualization if visible
        if (bnVisualizationContainer.style.display === 'block' && simBayesianNetwork) {
          setTimeout(() => { drawBayesianNetworkVisualization(); populateBNLegend(); }, 50);
        }
        // Resize and redraw summary graphs in the list
        const summaryCanvases = document.querySelectorAll('.past-run-summary-graph');
        summaryCanvases.forEach(sc => {
          const itemDiv = sc.closest('.past-run-summary-item');
          if (itemDiv && itemDiv.dataset.runIndex !== undefined) {
            const runIndex = parseInt(itemDiv.dataset.runIndex);
            if (runIndex >= 0 && runIndex < completedRuns.length) {
              const run = completedRuns[runIndex];
              if (run) drawSinglePastRunSummaryGraph(sc, run);
            }
          }
        });
      }
    });

    // Initialize the application
    init();
  </script>
</body>

</html>
